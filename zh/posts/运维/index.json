[{"content":"Ubuntu修复grub引导失败 对于grub损坏是很多使用双系统的研友都会遇到的问题，如果grub损坏，最重要的后果是进不去ubuntu里面的图形化见面，但是幸运的是硬盘没有受损。大部分人遇到这种情况一般是重装系统，殊不知，其实grub损害是可以恢复的，主要操作如下:\n以下会涉及到一些grub的命令行，这里不做详细介绍。\n首先第一步，因为没有了图形画界面，我们需要知道到底有哪些硬盘，执行以下命令：\n1  cat (hd1, 或者 ls（hd1   然后双击Tab键补全，在这里不一定是hd1，也有可能是hd0，出现以下情况：\n由于我时windows和ubuntu共存的，所以会有几个磁盘是不用的，我们的目标在（hd1,gpt1)和(hd1,gpt8)，那么grub的核心文件究竟在哪里呢，我们执行如下命令：\n1  ls (hd1,gpt8)/boot/grub/   上面的（hd1,gpt8）根据你自己电脑而定，一个个试，直到找到你自己的grub为止3，一般是一个含有grub的文件，在哪个磁盘找到了，那么我们目标就在那里了。\n确定在哪个分区之后,可以按照下列命令执行：\n1 2 3 4 5  grub\u0026gt; set root=(hd1,gpt8) (我这里的分区是这个) grub\u0026gt; set prefix(hd1,gpt8)/boot/grub grub\u0026gt; insmod normal grub\u0026gt; normal #(在这里一般会弹出进入系统的界面，是不是看到一点点小希望了，但是如果单单只是这样的话，还是需要重装系统，因为不可能每次都执行这种操作吧)   接下来\u0026hellip;..\n在看到界面的时候按c，进入命令行\n输入：\n1  grub\u0026gt; cat (hd1,gpt8)/boot/grubs   可以看到，我们的mount point 是装在 /dev/sda8里面的，如果你不知道怎么确定，把几个磁盘都换一遍，接着，我们进行以下步骤：\n1 2 3  grub\u0026gt; linux /boot/vmlinuz-xxx-xxx root=/dev/sda8 grub\u0026gt; initrd /boot/initrd.img-xxx-xxx grub\u0026gt; boot(进入系统)   内核版本号 -xxx-xxx可以按Tab键查看后再手动补全\n进入系统后，打开terminator，输入以下命令：\n1 2  sudo update-grub sudo grub-install /dev/sda1   到此grub修复完成！！！\n","description":"Ubuntu修复grub引导失败","id":2,"section":"posts","tags":["test"],"title":"Ubuntu修复grub引导失败","uri":"https://ymmeng.github.io/zh/posts/ubuntu%E4%BF%AE%E5%A4%8Dgrub%E5%BC%95%E5%AF%BC%E5%A4%B1%E8%B4%A5/"},{"content":"组织RPC接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  syntax = \u0026#34;proto3\u0026#34;;package services.org;option go_package = \u0026#34;proto;proto\u0026#34;;service orgService { rpc Org(OrgID) returns (OrgInfoResponse) {}; rpc Update(OrgUpdateRequest) returns (OrgInfoResponse); rpc Members(OrgMemberRequest) returns (UserResponse); rpc RemoveMembers(MembersRequest) returns (Status); rpc UpdateMemberRole(MembersRequest) returns (Status);}message OrgID { string uuid = 1;}message User { string uuid = 1; string name = 2; string email =3; string avatar = 4;}message OrgInfoResponse { string uuid =1; string name =2; int32 status = 3; string avatar = 4; int32 membersCount = 5; repeated User userInfo =6;}message OrgUpdateRequest { string uuid = 1; string name =2; oneof hasStatus{ int32 status = 3; } string avatar = 4;}message OrgMemberRequest { string uuid = 1; string keyWords = 2; string umeta = 3; int32 page = 4; int32 limit = 5;}message UserResponse { int32 count =1; repeated string user=2;}message MembersRequest { string orgId =1 ; string uId = 2; oneof hasSoft { int32 soft = 3; } repeated string userId =4; int32 userRole = 5;}message Status{ string OK =1; int32 Count = 2;}  ","description":"组织接口","id":3,"section":"posts","tags":["test"],"title":"组织接口","uri":"https://ymmeng.github.io/zh/posts/%E7%BB%84%E7%BB%87%E6%8E%A5%E5%8F%A3/"},{"content":"演示 1 2 3 4 5 6 7 8 9  添加父亲，也就是初始化git仓库 git init 添加儿子们，添加子模块 git submodule add https:xxx.com/xxx.git 找回儿子们，因为在clone主仓库的时候，git默认是不会把子模块给clone下来，所以需要使用以下命令 git submodule update --init --recursive   ","description":"git submodule 使用","id":4,"section":"posts","tags":["git","submodule"],"title":"git submodule 使用","uri":"https://ymmeng.github.io/zh/posts/%E5%89%8D%E7%AB%AF/git-submodule%E4%BD%BF%E7%94%A8/"},{"content":"演示 1 2 3 4 5 6 7 8 9  添加父亲，也就是初始化git仓库 git init 添加儿子们，添加子模块 git submodule add https:xxx.com/xxx.git 找回儿子们，因为在clone主仓库的时候，git默认是不会把子模块给clone下来，所以需要使用以下命令 git submodule update --init --recursive   ","description":"git submodule 使用","id":5,"section":"posts","tags":["git","submodule"],"title":"git submodule 使用","uri":"https://ymmeng.github.io/zh/posts/%E8%BF%90%E7%BB%B4/git-submodule%E4%BD%BF%E7%94%A8/"},{"content":"1.0 传统布局和 flex 布局对比 1.1 传统布局  兼容性好 布局繁琐 局限性，不能再移动端很好的布局  1.2 flex 布局  操作方便，布局极其简单，移动端使用比较广泛 pc 端浏览器支持情况比较差 IE11 或更低版本不支持 flex 或仅支持部分  1.3 建议  如果是 pc 端页面布局，还是采用传统方式 如果是移动端或者是不考虑兼容的 pc 则采用 flex  2.0 flex 布局原理  flex 是 flexible Box 的缩写，意为\u0026quot;弹性布局\u0026rdquo;，用来为盒状模型提供最大的灵活性，任何一个容器都可以指定为 flex 布局。 当我们为父盒子设为 flex 布局以后，子元素的 float、clear 和 vertical-align 属性将失效。 flex 布局又叫伸缩布局 、弹性布局 、伸缩盒布局 、弹性盒布局 采用 Flex 布局的元素，称为 Flex 容器（flex  container），简称\u0026quot;容器\u0026rdquo;。它的所有子元素自动成为容器成员，称为 Flex 项目（flex\nitem），简称\u0026quot;项目\u0026rdquo;。\n总结：就是通过给父盒子添加 flex 属性，来控制子盒子的位置和排列方式\n3.0 父项常见属性  flex-direction：设置主轴的方向 justify-content：设置主轴上的子元素排列方式 flex-wrap：设置子元素是否换行 align-content：设置侧轴上的子元素的排列方式（多行） align-items：设置侧轴上的子元素排列方式（单行） flex-flow：复合属性，相当于同时设置了 flex-direction 和 flex-wrap  3.1 flex-direction 设置主轴的方向   在 flex 布局中，是分为主轴和侧轴两个方向，同样的叫法有 ： 行和列、x 轴和 y 轴\n  默认主轴方向就是 x 轴方向，水平向右\n  默认侧轴方向就是 y 轴方向，水平向下\n  注意： 主轴和侧轴是会变化的，就看 flex-direction 设置谁为主轴，剩下的就是侧轴。而我们的子元素是跟着主轴来排列的\n  3.2 justify-content 设置主轴上的子元素排列方式 3.3 flex-wrap 设置是否换行  默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap 属性定义，flex 布局中默认是不换行的。 nowrap 不换行 wrap 换行  3.4 align-items 设置侧轴上的子元素排列方式（单行 ）  该属性是控制子项在侧轴（默认是 y 轴）上的排列方式 在子项为单项（单行）的时候使用 flex-start 从头部开始 flex-end 从尾部开始 center 居中显示 stretch 拉伸  3.5 align-content 设置侧轴上的子元素的排列方式（多行） 设置子项在侧轴上的排列方式 并且只能用于子项出现 换行 的情况（多行），在单行下是没有效果的。\n3.6 align-content 和 align-items 区别  align-items 适用于单行情况下， 只有上对齐、下对齐、居中和 拉伸 align-content 适应于换行（多行）的情况下（单行情况下无效）， 可以设置 上对齐、下对齐、居中、拉伸以及平均分配剩余空间等属性值。 总结就是单行找 align-items 多行找 align-content  3.7 flex-flow 属性是 flex-direction 和 flex-wrap 属性的复合属性 1  flex-flow:row wrap;   4.0 flex 布局子项常见属性  flex 子项目占的份数 align-self 控制子项自己在侧轴的排列方式 order 属性定义子项的排列顺序（前后顺序）  4.1 flex 属性 flex 属性定义子项目分配剩余空间，用 flex 来表示占多少份数。\n1 2 3 4  .item { flex: \u0026lt;number\u0026gt;; /* 默认值 0 */ }   4.2 align-self 控制子项自己在侧轴上的排列方式 align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖 align-items 属性。\n默认值为 auto，表示继承父元素的 align-items 属性，如果没有父元素，则等同于 stretch。\n1 2 3 4  span:nth-child(2) { /* 设置自己在侧轴上的排列方式 */ align-self: flex-end; }   4.3 order 属性定义项目的排列顺序 数值越小，排列越靠前，默认为 0。\n注意：和 z-index 不一样。\n1 2 3  .item { order: \u0026lt;number\u0026gt;; }   5.0 携程网首页案例制作 携程网链接：http://m.ctrip.com\n1.技术选型\n方案：我们采取单独制作移动页面方案\n技术：布局采取 flex 布局\n2.搭建相关文件夹\n3.设置视口标签以及引入初始化样式\n1 2 3 4  \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, user-scalable=no,initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;css/normalize.css\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;css/index.css\u0026#34;\u0026gt;   4.常用初始化样式\n1 2 3 4 5 6 7 8 9 10 11  body { max-width: 540px; min-width: 320px; margin: 0 auto; font: normal 14px/1.5 Tahoma,\u0026#34;Lucida Grande\u0026#34;,Verdana,\u0026#34;Microsoft Yahei\u0026#34;,STXihei,hei; color: #000; background: #f2f2f2; overflow-x: hidden; -webkit-tap-highlight-color: transparent; }   5.模块名字划分\n","description":"123","id":6,"section":"posts","tags":["flex"],"title":"传统布局和 flex 布局对比","uri":"https://ymmeng.github.io/zh/posts/%E5%89%8D%E7%AB%AF/html%E4%B8%ADflex%E5%B8%83%E5%B1%80%E4%BD%BF%E7%94%A8/"},{"content":"提示框 使用方法 1     看起来的样子 warning, success, info, danger this is a text 框 Markdownify框\n1     简单的盒子\n1     折叠 1     注意 1     标签 1     ","description":"提示框","id":7,"section":"posts","tags":["hugo"],"title":"提示框","uri":"https://ymmeng.github.io/zh/posts/%E6%8F%90%E7%A4%BA%E6%A1%86/"},{"content":"用户 接口 User 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  string userID通过用户的uuid查询 users 数据表获取用户的详细信息。 umeta查询后需要做链接到　umetas数据表。通过userid 来查询　umetas 的指定用户字段的所有信息。 // 用户信息返回数据 message UserResponse{ string userId=1; string name=2; string email=3; string avatar=4; int32 status=5; int32 privacy=6; bool verified=7; int32 createdAt=8; repeated Umeta umetas=9;}  Create 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  请求数据的参数包括用户的用户名、邮箱、和php生成的默认密码(123456)。 返回的用户数据userid是自动生成，其他字段为默认值。用户名、邮箱、密码为请求的参数值。 返回给php后，php要发送邮箱验证。 如果该用户还未验证，那么　验证字段为空，　如果用户验证后为验证时的时间戳。 // 用户基础信息请求数据 message UserBasicRequest{ string name=1; string email=2; string password=3;}// 用户信息返回数据 message UserResponse{ string userId=1; string name=2; string email=3; string avatar=4; int32 status=5; int32 privacy=6; bool verified=7; int32 createdAt=8; repeated Umeta umetas=9;}  Update 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  首先通过userid去指定操作某个用户，除了password和resetTotp以外，其他按请求值修改。 如果password没传，就不修改密码;如果传了，验证oldPassword是否跟数据库中的密码相同(go、php)，php传密文直接通过go去对比密码，如果密码对比不上，返回数据都是空，如果都是空，证明更改密码失败。 如果二步验证传了，把　users数据表中的二步验证字段设置为php随机生成的secret。 // 用户详细信息请求数据 message UserDetailRequest{ string userId=1; string name=2; int32 Status=3; int32 privacy=4; // password是否传32, 88, 44, 66, 28, 36, 74, 65}  oneof hasPassword{ string password=5; } string oldPassword=6; repeated Umeta umetas=7; // 是否重置二步验证  oneof hasResetTotp{ string resetTotp=8;}// 用户信息返回数据 message UserResponse{ string userId=1; string name=2; string email=3; string avatar=4; int32 status=5; int32 privacy=6; bool verified=7; int32 createdAt=8; repeated Umeta umetas=9;}  好友 AddFriends-添加好友 1 2 3 4 5 6 7 8 9 10 11  添加好友需要当前用户的userid和待添加好友邮箱列表。 通过邮箱到 users 数据表中获取好友的uuid。 然后和当前的userid建立关联。在friends表中建立。 如果对方设置添加好友哪里是任何人能添加就是　１。如果需要认证就是　0返回好友信息列表 // 添加好友请求数据 message FriendRequest{ string userId=1; repeated string emails=2;}  Friends-获取好友列表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  通过请求数据userid来指定获取某个用户的所有好友。 verified 好友验证过滤，不传递返回所有，1返回已通过好友验证的，0返回待验证好友 // 好友列表请求数据 message FriendsRequest{ string userId=1; string verified=2; int32 page=3; int32 limit=4;}//好友列表返回数据 message FriendResponse{ repeated UserResponse friends=1;}  RemoveFriends-移除好友 1 2 3 4 5 6 7 8  通过请求值：当前用户uuid和待移除好友邮箱列表（通过邮箱获取uuid），之后在friend数据表中把关联移除掉。 //　请求 message FriendRequest{ string userId=1; repeated string emails=2;}// 返回操作码   VerifyFriends－验证好友 1 2  通过当前用户的uuid和好友邮箱列表（通过邮箱获取uuid），之后在friends 数据表中把　verified的值由0变１返回操作码。   ","description":"git submodule 使用","id":8,"section":"posts","tags":["git","submodule"],"title":"用户模块","uri":"https://ymmeng.github.io/zh/posts/%E7%94%A8%E6%88%B7%E6%A8%A1%E5%9D%97/"},{"content":"前提准备 1.1配置go代理并开启go mod模式：\n1 2  go env -w GO111MODULE=\u0026#34;on\u0026#34; go env -w GOPROXY=\u0026#34;https://goproxy.cn,direct\u0026#34;   1.2使用go mod初始化项目并下载依赖包\n1 2  go mod init mypoject go mod tidy   1.3下载gin框架\n1  go get -u github.com/gin-gonic/gin   快速入门 运行下列代码并访问http://localhost:8080/helloworld您将看到效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  package main import \u0026#34;github.com/gin-gonic/gin\u0026#34; func main() { //初始化路由  r := gin.Default() //当访问http://localhost:8080/helloworld的时候就会执行匿名函数  r.GET(\u0026#34;/helloworld\u0026#34;, func(c *gin.Context) { // c.JSON：返回JSON格式的数据  c.JSON(200, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;helloworld！\u0026#34;, }) }) r.Run() // listen and serve on 0.0.0.0:8080 }    Run()方法默认是8080端口，如果想要改变端口，可以：Run(\u0026quot;:9000\u0026quot;)，这样就变成了9000端口。\n 代码示例 如下列代码，虽然访问的路由是一样的，当路由请求的方式不一样，这样就不会造成问题。\n 使用浏览器获取其他请求麻烦？来试试ApiPost：https://www.apipost.cn/download.html\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  func main() { r := gin.Default() r.GET(\u0026#34;/test\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;GET\u0026#34;, }) }) r.POST(\u0026#34;/test\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;POST\u0026#34;, }) }) r.PUT(\u0026#34;/test\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;PUT\u0026#34;, }) }) r.DELETE(\u0026#34;/test\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;DELETE\u0026#34;, }) }) }   会不会发现上面我们的路由组都是独立的，看着没有秩序？来试试路由组\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  func main() { r := gin.Default() v1 = r.Group(\u0026#34;/v1\u0026#34;) { v1.GET(\u0026#34;/test\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;GET\u0026#34;, }) }) v1.POST(\u0026#34;/test\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;POST\u0026#34;, }) }) v1.PUT(\u0026#34;/test\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;PUT\u0026#34;, }) }) v1.DELETE(\u0026#34;/test\u0026#34;, func(c *gin.Context) { c.JSON(200, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;DELETE\u0026#34;, }) }) } }   现在的话，我们这四种路由请求都数据v1的这个路由组下面，这时候如果想要访问路由的话就需要在子路由前加上路由组的URI，如v1.Get请求：http://127.0.0.1:8080/v1/test\n","description":"","id":9,"section":"posts","tags":null,"title":"go-gin框架使用","uri":"https://ymmeng.github.io/zh/posts/%E5%90%8E%E7%AB%AF/go-gin%E6%A1%86%E6%9E%B6%E4%BD%BF%E7%94%A8/"},{"content":"1.1 常用类型指示符    类型 描述     %b 整数，显示为二进制   %c 整数，显示为ASCII字符   %d 整数，显示为有符号十进制数   %f 浮点数，显示为浮点数   %o 整数，显示为八进制数   %s 字符串，显示为字符串   %u 整数，显示为无符号十进制数   %x 整数，显示为小写的十六进制数   %X 整数，显示为大写的十六进制数    1.2 基本数据类型    类型 名称     Integer 整数   Float 单精度浮点数   Double 又精度浮点数   String 字符串   Boolean 布尔   Array 数组   Object 对象    1.3 检测变量的函数    函数 功能 返回值     Gettype() 获取变量的类型 基本数据类型中的其中一种   Settype() 设置变量的类型 Bool(1:true 0:false(or ’’))   Isset() 用来判断一个变量是否存在 Bool   Unset() 释放给定的变量 Void   Empty() 检测一个变量的值是否为空 Bool   is_int() is_integer() 检测变量是否是整数 Bool   Is_string() 检测变量是否是字符串 bool   Is_numeric 检测变量是否为数字或数字字符串 bool   Is_null 检测变量是否为 NULL bool   Intval() 获取变量的整数值 int    1.4 超级全局变量    变量名 作用     $GLOBALS 所有全局变量数组   $_SERVER 服务器环境变量数组   $_GET 通过GET方式传递给该脚本的变量数组   $_POST 通过POST方式传递给该脚本的变量数组   $_COOKIE COOKIE变量数组   $_FILES 与文件上传相关的变量数组   $_ENV 环境变量数组   $_REQUEST 所用用户输入的变量数组   $_SESSION 会话变量数组    1.5 部分常用的转义字符    转义序列 描述     \\n 换行符   \\r 回车   \\t 水平制表图   \\ 反斜杠   $ 美元符   \\” 双引号    PHP预定义常量与表单 2.1 $_SERVER 1 2 3 4 5 6 7 8 9 10 11 12 13 14  代码 \u0026lt;?php echo $_SERVER[\u0026#34;SERVER_NAME\u0026#34;]; echo \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; echo $_SERVER[\u0026#34;SERVER_PORT\u0026#34;]; echo \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; echo $_SERVER[\u0026#34;DOCUMENT_ROOT\u0026#34;]; echo \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; ?\u0026gt; 结果 127.0.0.1 /home/ymmeng/code/php/lara/example-app/public 8000   2.2 自定义常量：define() 1 2 3 4 5 6 7  \u0026lt;?php define(\u0026#34;TOTAL\u0026#34;,100); echo TOTAL;//100 echo \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; define(\u0026#34;TOTAL\u0026#34;,200); echo TOTAL;//100 ?\u0026gt;   2.3 自定义常量：const 1 2  const Name = \u0026#39;name\u0026#39;; echo Name;   2.4 访问表单变量 1 2 3 4 5 6 7  \u0026lt;?php echo $username;//简短风格，容易与变量名混淆，不推荐使用。 echo \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; echo $_POST[\u0026#39;username\u0026#39;];//中等风格，4.1.0版后支持，推荐 echo \u0026#39;\u0026lt;br/\u0026gt;\u0026#39;; echo $HTTP_POST_VARS[\u0026#39;username\u0026#39;];//冗长风格，已过时，将来可能会被剔除 ?\u0026gt;   2.5 字符串连接用 1 2 3 4 5  \u0026lt;?php echo \u0026#34;the student name is ：\u0026#34;.$_POST[\u0026#39;username\u0026#39;]; echo \u0026#34;\u0026lt;br/\u0026gt;\u0026#34;; echo \u0026#34;welcome to \u0026#34;.\u0026#34;school\u0026#34;; ?\u0026gt;   2.6 魔术常量 1 2 3 4 5  \u0026lt;?php echo __LINE__,\u0026#39;\u0026lt;br/\u0026gt;\u0026#39;;\t//获取当前行号 echo __FILE__,\u0026#39;\u0026lt;br/\u0026gt;\u0026#39;;\t//文件的完整路径 echo __DIR__,\u0026#39;\u0026lt;br/\u0026gt;\u0026#39;;\t//文件的完整目录 ?\u0026gt;   数据类型转换 tsp: 1 2 3 4  \u0026lt;?php $num1 = 10\t//十进制=\u0026gt;10 $num1 = 010\t//八进制=\u0026gt;8 $num1 = 0x10\t//十六进制=\u0026gt;16   3.1 强制类型转换 1 2 3  \u0026lt;?php $num = \u0026#39;10\u0026#39;; var_dump($num,(int)$num,(float)$num) // string(2) \u0026#39;10\u0026#39; int(10) float(10)   3.2 逻辑运算符 1 2 3 4 5  \u0026amp;\t//与 |\t//或 \u0026amp;\u0026amp;\t//短路与 ||\t//短路或 !\t//非   ","description":"","id":10,"section":"posts","tags":null,"title":"PHP常用关键字","uri":"https://ymmeng.github.io/zh/posts/%E5%90%8E%E7%AB%AF/php%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97/"},{"content":"Golang etcd/clientv3报错： etcd undefined: resolver.BuildOption 故障描述 golang版本\n1 2  go version go version go1.14 windows/amd64   包管理器go.mod\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  module go_micro go 1.14 require ( github.com/coreos/etcd v3.3.25+incompatible // indirect \tgithub.com/dustin/go-humanize v1.0.0 // indirect \tgithub.com/golang/protobuf v1.4.3 github.com/google/go-cmp v0.5.0 // indirect \tgithub.com/gorilla/websocket v1.4.2 // indirect \tgithub.com/micro/go-micro/v2 v2.9.1 golang.org/x/net v0.0.0-20201224014010-6772e930b67b // indirect \tgolang.org/x/sys v0.0.0-20201223074533-0d417f636930 // indirect \tgolang.org/x/text v0.3.4 // indirect \tgoogle.golang.org/protobuf v1.23.0 gopkg.in/yaml.v2 v2.2.8 // indirect )   在安装go get go.etcd.io/etcd/clientv3时出错\n错误信息：\n1 2 3 4 5 6  # github.com/coreos/etcd/clientv3/balancer/resolver/endpoint ../../pkg/mod/github.com/coreos/etcd@v3.3.18+incompatible/clientv3/balancer/resolver/endpoint/endpoint.go:114:78: undefined: resolver.BuildOption ../../pkg/mod/github.com/coreos/etcd@v3.3.18+incompatible/clientv3/balancer/resolver/endpoint/endpoint.go:182:31: undefined: resolver.ResolveNowOption # github.com/coreos/etcd/clientv3/balancer/picker ../../pkg/mod/github.com/coreos/etcd@v3.3.18+incompatible/clientv3/balancer/picker/err.go:37:44: undefined: balancer.PickOptions ../../pkg/mod/github.com/coreos/etcd@v3.3.18+incompatible/clientv3/balancer/picker/roundrobin_balanced.go:55:54: undefined: balancer.PickOptions   解决方法 将grpc版本替换成v1.26.0版本\n1. 修改依赖为v1.26.0 1  go mod edit -require=google.golang.org/grpc@v1.26.0   下载v1.26.0版本的grpc\n1  go get -u -x google.golang.org/grpc@v1.26.0   etcd连接成功!\n","description":"","id":11,"section":"posts","tags":null,"title":"解决Golang1.14 etcd/clientv3报错：etcd undefined: resolver.BuildOption","uri":"https://ymmeng.github.io/zh/posts/%E5%90%8E%E7%AB%AF/%E8%A7%A3%E5%86%B3golang1.14-etcdclientv3%E6%8A%A5%E9%94%99etcd-undefined-resolver.buildoption/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":13,"section":"gallery","tags":null,"title":"卡通","uri":"https://ymmeng.github.io/zh/gallery/cartoon/"},{"content":"Sample images from Pixabay\nSample images from\nSample images from\nSample images from\n   ","description":"photo gallery","id":14,"section":"gallery","tags":null,"title":"图片","uri":"https://ymmeng.github.io/zh/gallery/photo/"},{"content":"Written in Go, Hugo is an open source static site generator available under the Apache Licence 2.0. Hugo supports TOML, YAML and JSON data file types, Markdown and HTML content files and uses shortcodes to add rich content. Other notable features are taxonomies, multilingual mode, image processing, custom output formats, HTML/CSS/JS minification and support for Sass SCSS workflows.\nHugo makes use of a variety of open source projects including:\n https://github.com/russross/blackfriday https://github.com/alecthomas/chroma https://github.com/muesli/smartcrop https://github.com/spf13/cobra https://github.com/spf13/viper  Hugo is ideal for blogs, corporate websites, creative portfolios, online magazines, single page applications or even a website with thousands of pages.\nHugo is for people who want to hand code their own website without worrying about setting up complicated runtimes, dependencies and databases.\nWebsites built with Hugo are extremelly fast, secure and can be deployed anywhere including, AWS, GitHub Pages, Heroku, Netlify and any other hosting provider.\nLearn more and contribute on GitHub.\n","description":"Hugo, the world’s fastest framework for building websites","id":19,"section":"","tags":null,"title":"关于","uri":"https://ymmeng.github.io/zh/about/"},{"content":"blenderAPI data数据 可以访问blender中的所有数据\n可以进行材质属性、物体大小等进行修改\ncontext 只能访问当前激活的物体\nops 操作指令，比如按钮什么的，或者创建物体\noperators\ntypes 所有实现的‘class类模块’定义\nprops blender中properties属性管理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  1、invoke\r初始化\rself.execute(context):调用execute\r{\u0026#39;RUNNING_MODAL\u0026#39;}:调用modal，配合context.window_manager.modal_handler_add(self)\rdef invoke(self,context,event)\r#event 对键盘按键的检测，在operator的执行中，对快捷键进行检测\r 2、execute\r执行操作\r3、modal\r一直运行，例如Fly-Mode，G，R，S的实现\r4、poll：民义检测\r用来检测状态\r5、返回值\rinvoke execute modal 必须返回固定值：\r\u0026#39;RUNNING_MODAL\u0026#39;：运行modal\r\u0026#39;CANCELLED\u0026#39;：取消操作（右键）无undo\r\u0026#39;FINISHED\u0026#39;:确定操作（左键）：有undo\r\u0026#39;PASS_THROUGH\u0026#39;\r\u0026#39;INTERFACE\u0026#39;\rWindowManager(ID)\r  utils 管理自身的小工具\npath 访问系统的文件系统\n如\nbpy.path.abspath\n获取文件的当前路径绝对路径\nbpy.path.basename\nbpy.path.repath\n命名规范 operator ：_OT_\nmenu：_MT_\nheader：_HT_\npanel：_PT_\n面板操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  class className:\r#属性\r def poll():\r#运行前的手动判断\r def draw_header():\r#绘制标题头\r def draw():\r#绘制主要内容\r - bl_label：别名\r- bl_idname：panel的程序访问名字\r- bl_space_type：各个ui_type对应的值\r- bl_options：显示状态\r- bl_category：分组标签\r- bl_parent_id\r- bl_region_ty\r- UI：N面板\r- CHANNELS：文件选择窗口\r- WINDOW和bl_context搭配用\r- bl_context/bl_region_type/bl_space_type：三个搭配使用\r按钮：\roperator(\u0026#39;my.button\u0026#39;,text=\u0026#39;name\u0026#39;,emboss=False,depress=True)\r#关键字\r sublayout\t子布局\rltem\t控件项\r  关于曲线 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  bpy.data.objects[\u0026#39;objectName\u0026#39;].animation_data.action.fcurves\rbpy.data.actions[\u0026#39;curveGroupName\u0026#39;].fcurves[\u0026#39;curveName\u0026#39;]\rlen(boy.context.object.animation_data.action.fcurves)\t#获取当前物体曲线数量\r bpy.context.object.animation_data.action.fcurves[4].mute = False\t#让曲线是否生效\r bpy.context.object.animation_data.action.fcurves[4].lock = False\t#锁定曲线\r bpy.context.object.animation_data.action.fcurves[4].select = True\t#选择该曲线\r bpy.ops.graph.hide(unselected=True)\t#隐藏未选中的\r bpy.data.window_managers[\u0026#39;WinMan\u0026#39;].(null) = True\r#插入关键帧\r 继承函数：bpy_struct.keyframe_insert\r(继承bpy_struct类)\r参数：\rdata_path 数据路径，例如：location位置\rindex\t索引\t例如：位置xyz（0，1，2）\rframe\t帧数 默认为当前，时间轴选中帧\rgroup\t分组 Object Transforms（物体-变换）\rbl_info = {\r\u0026#34;name\u0026#34;: \u0026#34;BL_ammiel_v0_1\u0026#34;,\r\u0026#34;description\u0026#34;: \u0026#34;BL_ammiel_v0_1\u0026#34;,\r\u0026#34;author\u0026#34;: \u0026#34;.\u0026#34;,\r\u0026#34;version\u0026#34;: (0, 0, 1),\r\u0026#34;blender\u0026#34;: (2, 80, 0),\r\u0026#34;location\u0026#34;: \u0026#34;Everywhere\u0026#34;,\r\u0026#34;category\u0026#34;: \u0026#34; Blender Box\u0026#34;\r}\ractions\t动作\rarmatures\t骨架\rcurves\t曲线\rbpy.ops.graph\r  ","description":"","id":23,"section":"posts","tags":null,"title":"","uri":"https://ymmeng.github.io/zh/posts/python/blenderapi/"},{"content":"Python函数 1、 函数的参数 2.11 形参的第三种:动态参数 动态接收位置参数：*args\n我们按照上面的例子继续写，如果我请你吃的内容很多，但是我又不想用多个参数接收，那么我就可以使用动态参数*args\n1 2 3 4 5  def eat(*args):\rprint(\u0026#39;我请你吃：\u0026#39;,args)\reat(\u0026#39;蒸羊羔儿\u0026#39;,\u0026#39;蒸熊掌\u0026#39;,\u0026#39;蒸鹿尾儿\u0026#39;,\u0026#39;烧花鸭\u0026#39;,\u0026#39;烧雏鸡\u0026#39;,\u0026#39;烧子鹅\u0026#39;)\r# 运行结果：\r #我请你吃： (\u0026#39;蒸羊羔儿\u0026#39;, \u0026#39;蒸熊掌\u0026#39;, \u0026#39;蒸鹿尾儿\u0026#39;, \u0026#39;烧花鸭\u0026#39;, \u0026#39;烧雏鸡\u0026#39;, \u0026#39;烧子鹅\u0026#39;)\r   解释一下上面参数的意义：首先来说args，args就是一个普通的形参，但是如果你在args前面加一个，那么就拥有了特殊的意义：在python中除了表示乘号，他是有魔法的。+args，这样设置形参，那么这个形参会将实参所有的位置参数接收，放置在一个元组中，并将这个元组赋值给args这个形参，这里起到魔法效果的是 * 而不是args，a也可以达到刚才效果，但是我们PEP8规范中规定就使用args，约定俗成的。\n练习：传入函数中数量不定的int型数据，函数计算所有数的和并返回。\n1 2 3 4 5  def my_max(*args):\rn = 0\rfor i in args:\rn += i\rreturn n\r  *动态接收关键字参数: *kwargs\n实参角度有位置参数和关键字参数两种，python中既然有*args可以接受所有的位置参数那么肯定也有一种参数接受所有的关键字参数，那么这个就是kwargs，同理这个是具有魔法用法的，kwargs约定俗成使用作为形参。举例说明：**kwargs，是接受所有的关键字参数然后将其转换成一个字典赋值给kwargs这个形参。\n1 2 3  def func(**kwargs):\rprint(kwargs) # {\u0026#39;name\u0026#39;: \u0026#39;太白金星\u0026#39;, \u0026#39;sex\u0026#39;: \u0026#39;男\u0026#39;}\r func(name=\u0026#39;太白金星\u0026#39;,sex=\u0026#39;男\u0026#39;)\r  我们看一下动态参数的完成写法：\n1 2 3 4  def func(*args,**kwargs):\rprint(args) # (\u0026#39;蒸羊羔儿\u0026#39;, \u0026#39;蒸熊掌\u0026#39;, \u0026#39;蒸鹿尾儿\u0026#39;)\r print(kwargs) # {\u0026#39;name\u0026#39;: \u0026#39;太白金星\u0026#39;, \u0026#39;sex\u0026#39;: \u0026#39;男\u0026#39;}\r func(\u0026#39;蒸羊羔儿\u0026#39;, \u0026#39;蒸熊掌\u0026#39;, \u0026#39;蒸鹿尾儿\u0026#39;,name=\u0026#39;太白金星\u0026#39;,sex=\u0026#39;男\u0026#39;)\r  如果一个参数设置了动态参数，那么他可以接受所有的位置参数，以及关键字参数，这样就会大大提升函数拓展性，针对于实参参数较多的情况下，解决了一一对应的麻烦。\n2.12 * 的魔性用法 刚才我们研究了动态参数，其实有的同学对于魔法用法 * 比较感兴趣，那么那的魔性用法不止这么一点用法，我们继续研究：\n函数中分为打散和聚合。\n函数外可以处理剩余的元素。\n函数的打散和聚合\n聚合\n刚才我们研究了，在函数定义时，如果我只定义了一个形参称为args，那么这一个形参只能接受几个实参？ 是不是只能当做一个位置参数对待？它只能接受一个参数：\n1 2 3  def eat(args):\rprint(\u0026#39;我请你吃：\u0026#39;,args) # 我请你吃： 蒸羊羔儿\r eat(\u0026#39;蒸羊羔儿\u0026#39;)\r  但是如果我给其前面加一个* 那么args可以接受多个实参，并且返回一个元组，对吧？ （**kwargs也是同理将多个关键字参数转化成一个字典返回）所以在函数的定义时： *起到的是聚合的作用。\n打散\n此时不着急给大家讲这个打散，而是出一个小题：你如何将三个数据（这三个数据都是可迭代对象类型）s1 = \u0026lsquo;alex\u0026rsquo;,l1 = [1, 2, 3, 4], tu1 = (\u0026lsquo;武sir\u0026rsquo;, \u0026lsquo;太白\u0026rsquo;, \u0026lsquo;女神\u0026rsquo;,)的每一元素传给动态参数*args？（就是args最终得到的是 (\u0026lsquo;a\u0026rsquo;,\u0026lsquo;l\u0026rsquo;,\u0026lsquo;e\u0026rsquo;,\u0026lsquo;x\u0026rsquo;, 1, 2, 3, 4,\u0026lsquo;武sir\u0026rsquo;, \u0026lsquo;太白\u0026rsquo;, \u0026lsquo;女神\u0026rsquo;,）?有人说这还不简单么？我直接传给他们不就行了？\n1 2 3 4 5 6  s1 = \u0026#39;alex\u0026#39;\rl1 = [1, 2, 3, 4]\rtu1 = (\u0026#39;武sir\u0026#39;, \u0026#39;太白\u0026#39;, \u0026#39;女神\u0026#39;,)\rdef func(*args):\rprint(args) # (\u0026#39;alex\u0026#39;, [1, 2, 3, 4], (\u0026#39;武sir\u0026#39;, \u0026#39;太白\u0026#39;, \u0026#39;女神\u0026#39;))\r func(s1,l1,tu1)\r  这样肯定是不行，他会将这个三个数据类型当成三个位置参数传给args，没有实现我的要求。\n好像你除了直接写，没有别的什么办法，那么这里就得用到我们的魔法用法 ：*\n1 2 3 4 5 6  s1 = \u0026#39;alex\u0026#39;\rl1 = [1, 2, 3, 4]\rtu1 = (\u0026#39;武sir\u0026#39;, \u0026#39;太白\u0026#39;, \u0026#39;女神\u0026#39;,)\rdef func(*args):\rprint(args) # (\u0026#39;a\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;x\u0026#39;, 1, 2, 3, 4, \u0026#39;武sir\u0026#39;, \u0026#39;太白\u0026#39;, \u0026#39;女神\u0026#39;)\r func(*s1,*l1,*tu1)\r  你看此时是函数的执行时，我将你位置参数的实参（可迭代类型）前面加上，相当于将这些实参给拆解成一个一个的组成元素当成位置参数，然后传给args,这时候这个好像取到的是打散的作用。所以在函数的执行时：，**起到的是打散的作用。\n1 2 3 4 5  dic1 = {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;age\u0026#39;: 18}\rdic2 = {\u0026#39;hobby\u0026#39;: \u0026#39;喝茶\u0026#39;, \u0026#39;sex\u0026#39;: \u0026#39;男\u0026#39;}\rdef func(**kwargs):\rprint(kwargs) # {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;age\u0026#39;: 18, \u0026#39;hobby\u0026#39;: \u0026#39;喝茶\u0026#39;, \u0026#39;sex\u0026#39;: \u0026#39;男\u0026#39;}\r func(**dic1,**dic2)\r  *处理剩下的元素\n*除了在函数中可以这样打散，聚合外，函数外还可以灵活的运用：\n1 2 3 4 5 6 7 8 9  # 之前讲过的分别赋值\r a,b = (1,2)\rprint(a, b) # 1 2\r # 其实还可以这么用：\r a,*b = (1, 2, 3, 4,)\rprint(a, b) # 1 [2, 3, 4]\r *rest,a,b = range(5)\rprint(rest, a, b) # [0, 1, 2] 3 4\r print([1, 2, *[3, 4, 5]]) # [1, 2, 3, 4, 5]\r   2.13 形参的顺序 到目前为止，从形参的角度我们讲了位置参数，默认值参数，动态参数*args，**kwargs，还差一种参数，需要讲完形参顺序之后，引出。先不着急，我们先看看已经讲的这些形参他的排列顺序是如何的呢？\n首先，位置参数，与默认参数他两个的顺序我们昨天已经确定了，位置参数必须在前面，即 ：位置参数，默认参数。\n那么动态参数*args，**kwargs放在哪里呢？\n动态参数*args，肯定不能放在位置参数前面，这样我的位置参数的参数就接收不到具体的实参了：\n1 2 3 4 5  # 这样位置参数a,b始终接收不到实参了，因为args全部接受完了\r def func(*args,a,b,sex=\u0026#39;男\u0026#39;):\rprint(args)\rprint(a,b)\rfunc(1, 2, 3, 4, 5)\r  那么动态参数必须在位置参数后面，他可以在默认参数后面么？\n1 2 3 4 5 6  # 这样也不行，我的实参的第三个参数始终都会将sex覆盖掉，这样失去了默认参数的意义。\r def func(a,b,sex=\u0026#39;男\u0026#39;,*args,):\rprint(args) # (4, 5)\r print(sex) # 3\r print(a,b) # 1 2\r func(1, 2, 3, 4, 5)\r  所以*args一定要在位置参数与默认值参数中间：位置参数，*args，默认参数。\n那么我的**kwargs放在哪里？**kwargs可以放在默认参数前面么？\n1 2 3 4 5 6 7 8  # 直接报错：因为**kwargs是接受所有的关键字参数，如果你想改变默认参数sex，你永远也改变不了，因为\r # 它会先被**kwargs接受。\r def func(a,b,*args,**kwargs,sex=\u0026#39;男\u0026#39;,):\rprint(args) # (4, 5)\r print(sex) # 3\r print(a,b) # 1 2\r print(kwargs)\rfunc(1, 2, 3, 4, 5)\r  所以截止到此：所有形参的顺序为：*位置参数，*args，默认参数，*kwargs。\n2.14 形参的第四种参数：仅限关键字参数 仅限关键字参数是python3x更新的新特性，他的位置要放在*args后面，kwargs前面（如果有kwargs），也就是默认参数的位置，它与默认参数的前后顺序无所谓，它只接受关键字传的参数：\n1 2 3 4 5 6 7 8 9 10 11  # 这样传参是错误的，因为仅限关键字参数c只接受关键字参数\r def func(a,b,*args,c):\rprint(a,b) # 1 2\r print(args) # (4, 5)\r # func(1, 2, 3, 4, 5)\r # 这样就正确了：\r def func(a,b,*args,c):\rprint(a,b) # 1 2\r print(args) # (3, 4)\r print(5)\rfunc(1, 2, 3, 4, c=5)\r  这个仅限关键字参数从名字定义就可以看出他只能通过关键字参数传参，其实可以把它当成不设置默认值的默认参数而且必须要传参数，不传就报错。\n所以形参角度的所有形参的最终顺序为：*位置参数，*args，默认参数，仅限关键字参数，*kwargs。\n1 2 3 4 5 6 7 8 9 10 11 12 13  课间考一道题：\rdef foo(a,b,*args,c,sex=None,**kwargs):\rprint(a,b)\rprint(c)\rprint(sex)\rprint(args)\rprint(kwargs)\r# foo(1,2,3,4,c=6)\r # foo(1,2,sex=\u0026#39;男\u0026#39;,name=\u0026#39;alex\u0026#39;,hobby=\u0026#39;old_woman\u0026#39;)\r # foo(1,2,3,4,name=\u0026#39;alex\u0026#39;,sex=\u0026#39;男\u0026#39;)\r # foo(1,2,c=18)\r # foo(2, 3, [1, 2, 3],c=13,hobby=\u0026#39;喝茶\u0026#39;)\r # foo(*[1, 2, 3, 4],**{\u0026#39;name\u0026#39;:\u0026#39;太白\u0026#39;,\u0026#39;c\u0026#39;:12,\u0026#39;sex\u0026#39;:\u0026#39;女\u0026#39;})\r   2.2 名称空间，作用域 2.21 名称空间： 接下来我们讲的内容，理论性的偏多，就是从空间角度，内存级别去研究python。首先我们看看什么是全局名称空间：\n在python解释器开始执行之后, 就会在内存中开辟一个空间, 每当遇到一个变量的时候, 就把变量名和值之间的关系记录下来, 但是当遇到函数定义的时候, 解释器只是把函数名读入内存, 表示这个函数存在了, 至于函数内部的变量和逻辑, 解释器是不关心的. 也就是说一开始的时候函数只是加载进来, 仅此而已, 只有当函数被调用和访问的时候, 解释器才会根据函数内部声明的变量来进行开辟变量的内部空间. 随着函数执行完毕, 这些函数内部变量占用的空间也会随着函数执行完毕而被清空.\n我们首先回忆一下Python代码运行的时候遇到函数是怎么做的，从Python解释器开始执行之后，就在内存中开辟里一个空间，每当遇到一个变量的时候，就把变量名和值之间对应的关系记录下来，但是当遇到函数定义的时候，解释器只是象征性的将函数名读如内存，表示知道这个函数存在了，至于函数内部的变量和逻辑，解释器根本不关心。\n等执行到函数调用的时候，Python解释器会再开辟一块内存来储存这个函数里面的内容，这个时候，才关注函数里面有哪些变量，而函数中的变量回储存在新开辟出来的内存中，函数中的变量只能在函数内部使用，并且会随着函数执行完毕，这块内存中的所有内容也会被清空。\n我们给这个‘存放名字与值的关系’的空间起了一个名字\u0026mdash;\u0026mdash;-命名空间。\n代码在运行伊始，创建的存储“变量名与值的关系”的空间叫做全局命名空间；\n在函数的运行中开辟的临时的空间叫做局部命名空间也叫做临时名称空间。\n现在我们知道了，py文件中，存放变量与值的关系的一个空间叫做全局名称空间，而当执行一个函数时，内存中会临时开辟一个空间，临时存放函数中的变量与值的关系，这个叫做临时名称空间，或者局部名称空间。\n其实python还有一个空间叫做内置名称空间：内置名称空间存放的就是一些内置函数等拿来即用的特殊的变量：input，print，list等等，所以，我们通过画图捋一下：\n那么这就是python中经常提到的三个空间。\n总结:\n\\1. 全局命名空间\u0026ndash;\u0026gt; 我们直接在py文件中, 函数外声明的变量都属于全局命名空间\n\\2. 局部命名空间\u0026ndash;\u0026gt; 在函数中声明的变量会放在局部命名空间\n\\3. 内置命名空间\u0026ndash;\u0026gt; 存放python解释器为我们提供的名字, list, tuple, str, int这些都是内置命名空间\n2.22 加载顺序： 所谓的加载顺序，就是这三个空间加载到内存的先后顺序，也就是这个三个空间在内存中创建的先后顺序，你想想他们能是同时创建么？肯定不是的，那么谁先谁后呢？我们捋顺一下：在启动python解释器之后，即使没有创建任何的变量或者函数，还是会有一些函数直接可以用的比如abs(-1),max(1,3)等等，在启动Python解释器的时候，就已经导入到内存当中供我们使用，所以肯定是先加载内置名称空间，然后就开始从文件的最上面向下一行一行执行，此时如果遇到了初始化变量，就会创建全局名称空间，将这些对应关系存放进去，然后遇到了函数执行时，在内存中临时开辟一个空间，加载函数中的一些变量等等。所以这三个空间的加载顺序为：内置命名空间(程序运行伊始加载)-\u0026gt;全局命名空间(程序运行中：从上到下加载)-\u0026gt;局部命名空间(程序运行中：调用时才加载。\n2.23 取值顺序： 取值顺序就是引用一个变量，先从哪一个空间开始引用。这个有一个关键点：从哪个空间开始引用这个变量。我们分别举例说明：\n1 2 3 4 5 6 7 8 9 10 11 12  # 如果你在全局名称空间引用一个变量，先从全局名称空间引用，全局名# 称空间如果没有，才会向内置名称空间引用。\r input = 666\rprint(input) # 666\r # 如果你在局部名称空间引用一个变量，先从局部名称空间引用，\r # 局部名称空间如果没有，才会向全局名称空间引用，全局名称空间在没有，就会向内置名称空间引用。\r input = 666\rprint(input) # 666\r input = 666\rdef func():\rinput = 111\rprint(input) # 111\r func()\r  所以空间的取值顺序与加载顺序是相反的，取值顺序满足的就近原则，从小范围到大范围一层一层的逐步引用。\n2.24 作用域 作用域就是作用范围, 按照生效范围来看分为全局作用域和局部作用域\n全局作用域: 包含内置命名空间和全局命名空间. 在整个文件的任何位置都可以使用(遵循 从上到下逐⾏执行).\n局部作用域: 在函数内部可以使用.\n作⽤域命名空间:\n1. 全局作用域: 全局命名空间 + 内置命名空间\n2. 局部作⽤域: 局部命名空间\n2.25 内置函数globals(),locals()\n这两个内置函数放在这里讲是在合适不过的，他们就直接可以反映作用域的内容，有助于我们理解作用域的范围。\nglobals(): 以字典的形式返回全局作用域所有的变量对应关系。\nlocals(): 以字典的形式返回当前作用域的变量的对应关系。\n这里一个是全局作用域，一个是当前作用域，一定要分清楚，接下来，我们用代码验证：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  # 在全局作用域下打印，则他们获取的都是全局作用域的所有的内容。\r a = 2\rb = 3\rprint(globals())\rprint(locals())\r\u0026#39;\u0026#39;\u0026#39;\r{\u0026#39;__name__\u0026#39;: \u0026#39;__main__\u0026#39;, \u0026#39;__doc__\u0026#39;: None, \u0026#39;__package__\u0026#39;: None,\r\u0026#39;__loader__\u0026#39;: \u0026lt;_frozen_importlib_external.SourceFileLoader object at 0x000001806E50C0B8\u0026gt;, \u0026#39;__spec__\u0026#39;: None, \u0026#39;__annotations__\u0026#39;: {},\r\u0026#39;__builtins__\u0026#39;: \u0026lt;module \u0026#39;builtins\u0026#39; (built-in)\u0026gt;, \u0026#39;__file__\u0026#39;: \u0026#39;D:/lnh.python/py project/teaching_show/day09~day15/function.py\u0026#39;,\r\u0026#39;__cached__\u0026#39;: None, \u0026#39;a\u0026#39;: 2, \u0026#39;b\u0026#39;: 3}\r\u0026#39;\u0026#39;\u0026#39;\r# 在局部作用域中打印。\r a = 2\rb = 3\rdef foo():\rc = 3\rprint(globals()) # 和上面一样，还是全局作用域的内容\r print(locals()) # {\u0026#39;c\u0026#39;: 3}\r foo()\r  2.3 高阶函数（函数的嵌套） 其实我们见到了嵌套这个词不陌生，之前我们讲过列表的嵌套，列表的嵌套就是一个列表中还有列表，可能那个列表中还有列表\u0026hellip;\u0026hellip;那么顾名思义，函数的嵌套，就是一个函数中，还有函数。\n想要玩明白函数的嵌套，关键点：只要遇见了函数名+()就是函数的调用. 如果没有就不是函数的调用，吃透这一点就算明白了。那么我们举例练习：找同学依次说出下面代码的执行顺序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  # 例1：\r def func1():\rprint(\u0026#39;in func1\u0026#39;)\rprint(3)\rdef func2():\rprint(\u0026#39;in func2\u0026#39;)\rprint(4)\rfunc1()\rprint(1)\rfunc2()\rprint(2)\r# 例2：\r def func1():\rprint(\u0026#39;in func1\u0026#39;)\rprint(3)\rdef func2():\rprint(\u0026#39;in func2\u0026#39;)\rfunc1()\rprint(4)\rprint(1)\rfunc2()\rprint(2)\r# 例3：\r def fun2(): print(2) def fun3(): print(6) print(4) fun3() print(8)\rprint(3)\rfun2()\rprint(5)\r  2.4 关键字：global、nonlocal global 讲这个关键字之前，先给大家看一个现象：\n1 2 3 4 5 6 7 8  a = 1\rdef func():\rprint(a)\rfunc()\ra = 1\rdef func():\ra += 1 # 报错\r func()\r  局部作用域对全局作用域的变量（此变量只能是不可变的数据类型）只能进行引用，而不能进行改变，只要改变就会报错，但是有些时候，我们程序中会遇到局部作用域去改变全局作用域的一些变量的需求，这怎么做呢？这就得用到关键字global：\nglobal第一个功能：在局部作用域中可以更改全局作用域的变量。\n1 2 3 4 5 6  count = 1\rdef search():\rglobal count\rcount = 2\rsearch()\rprint(count)\r  利用global在局部作用域也可以声明一个全局变量。\ndef func():\rglobal a\ra = 3\rfunc()\rprint(a)\r所以global关键字有两个作用：\n1，声明一个全局变量。\n2，在局部作用域想要对全局作用域的全局变量进行修改时，需要用到 global(限于字符串，数字)。\nnonlocal nonlocal是python3x新加的功能，与global用法差不多，就是在局部作用域如果想对父级作用域的变量进行改变时，需要用到nonlocal，当然这个用的不是很多，了解即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  def add_b():\rb = 42\rdef do_global():\rb = 10\rprint(b)\rdef dd_nonlocal():\rnonlocal b\rb = b + 20\rprint(b)\rdd_nonlocal()\rprint(b)\rdo_global()\rprint(b)\radd_b()\rnonlocal关键字举例\r  nonlocal的总结：\n1，不能更改全局变量。\n2，在局部作用域中，对父级作用域（或者更外层作用域非全局作用域）的变量进行引用和修改，并且引用的哪层，从那层及以下此变量全部发生改变。\n函数总结 ","description":"","id":24,"section":"posts","tags":null,"title":"","uri":"https://ymmeng.github.io/zh/posts/python/python%E5%87%BD%E6%95%B0/"},{"content":"一.什么是数据类型？ 什么是数据类型？\n　我们人类可以很容易的分清数字与字符的区别，但是计算机并不能呀，计算机虽然很强大，但从某种角度上看又很傻，除非你明确的告诉它，1是数字，“汉”是文字，否则它是分不清1和‘汉’的区别的，因此，在每个编程语言里都会有一个叫数据类型的东东，其实就是对常用的各种数据类型进行了明确的划分，你想让计算机进行数值运算，你就传数字给它，你想让他处理文字，就传字符串类型给他。Python中常用的数据类型有多种，如下：\n　整数(int) ,字符串(str),布尔值(bool),列表(list),元组(tuple),字典(dict),集合(set).\n int。数字：主要用于运算。1 ，2,3\u0026hellip; bool。判断真假：True, False. str。简单少量的储存数据，并进行相应的操作。name = \u0026lsquo;alex\u0026rsquo;, tuple。只读，不能更改。(1,\u0026lsquo;alex\u0026rsquo;) list：大量有序数据，[1,\u0026lsquo;ses\u0026rsquo;,True,[1,2,3],{\u0026lsquo;name\u0026rsquo;:\u0026lsquo;jinxin\u0026rsquo;}] dict：大量数据，且是关联性比较强的数据 {\u0026lsquo;name\u0026rsquo;:\u0026lsquo;jinxin\u0026rsquo;,\u0026lsquo;age\u0026rsquo;:18,\u0026lsquo;name_list\u0026rsquo;:[\u0026lsquo;张三\u0026rsquo;，\u0026lsquo;李四\u0026rsquo;]}  二.基础数据类型。 2.1数字int。 int，就是咱们常见的数据类型，主要是用于葛总运算，加减乘数等这里就不给你举例说明了。\n首先要给大家讲下是十进制与二进制之间的转换。\n​ 2.1.1 十进制二进制转换\n十进制整数转换为二进制整数采用\u0026quot;除2取余，逆序排列\u0026quot;法。具体做法是：用2整除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。\n　十进制小数转换成二进制小数采用\u0026quot;乘2取整，顺序排列\u0026quot;法。具体做法是：用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，此时0或1为二进制的最后一位。或者达到所要求的精度为止。\n　二进制转化成十进制:\n要从右到左用二进制的每个数去乘以2的相应次方,小数点后则是从左往右\n例如：二进制数1101.01转化成十进制\n1101.01（2）=120+021+122+123 +02-1+12-2=1+0+4+8+0+0.25=13.25（10）\n所以总结起来通用公式为：\nabcd.efg(2)=d20+c21+b22+a23+e2-1+f2-2+g*2-3（10）\n或者是：\n把二进制数首先写成加权系数展开式，然后按十进制加法规则求和。这种做法称为\u0026quot;按权相加\u0026quot;法。\n此时，1101=8+4+0+1=13\n再比如：二进制数100011转成十进制数可以看作这样：\n数字中共有三个1 即第一位一个，第五位一个，第六位一个，然后对应十进制数即2的0次方+2的1次方+2的5次方， 即\n100011=32+0+0+0+2+1=35\n　2.2.2 int操作方法\n因为数字主要是用于计算，所以针对于数字可以使用的方法除了那些运算之外，没有什么经常会用的方法，python给咱们提供了一种方法：bit_length()就是帮助你快速的计算整数在内存中占用的二进制码的长度.\n1 2 3  num = 10\rprint(num.bit_length()) # 当十进制用二进制表示时，最少使用的位数\r # 运行结果: 4\r   2.2布尔值bool。 布尔值就两种：True，False。就是反应条件的正确与否。\n真 1 True。\n假 0 False。\n这里补充一下int str bool 三者数据类型之间的转换。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  # int ---\u0026gt; bool\r i = 100\rprint(bool(i)) # True # 非零即True\r i1 = 0\rprint(bool(i1)) # False 零即False\r # bool ---\u0026gt; int\r t = True\rprint(int(t)) # 1 True --\u0026gt; 1\r t = False\rprint(int(t)) # 0 False --\u0026gt; 0\r # int ---\u0026gt; str\r i1 = 100\rprint(str(i1)) # \u0026#39;100\u0026#39;\r # str ---\u0026gt; int # 全部由数字组成的字符串才可以转化成数字\r s1 = \u0026#39;90\u0026#39;\rprint(int(s1)) # 90\r # str ---\u0026gt; bool\r s1 = \u0026#39;太白\u0026#39;\rs2 = \u0026#39;\u0026#39;\rprint(bool(s1)) # True 非空即True\r print(bool(s2)) # False\r # bool ---\u0026gt; str\r t1 = True\rprint(str(True)) # \u0026#39;True\u0026#39;\r   2.3字符串str。 Python中凡是用引号引起来的数据可以称为字符串类型，组成字符串的每个元素称之为字符，将这些字符一个一个连接起来，然后在用引号起来就是字符串。\ns1 = '太白nb'\r# 对于s1这个字符串来说，它由四个字符组成：太, 白, n, b。\r2.3.1、字符串的索引与切片。\n组成字符串的字符从左至右，依次排列，他们都是有顺序的，就好比是部队的队列，从左至右依次报号(从零开始) ：0,1,2,3\u0026hellip;.\n索引即下标，就是字符串组成的元素从第一个开始，初始索引为0以此类推。\na = 'ABCDEFGHIJK'\rprint(a[0])\rprint(a[3])\rprint(a[5])\rprint(a[7])\r切片就是通过索引（索引：索引：步长）截取字符串的一段，形成新的字符串（原则就是顾头不顾腚）。\n1 2 3 4 5 6  a = \u0026#39;ABCDEFGHIJK\u0026#39;\rprint(a[0:3]) # print(a[:3]) 从开头开始取0可以默认不写\r print(a[2:5])\rprint(a[:]) #默认到最后\r print(a[:-1]) # -1 是列表中最后一个元素的索引，但是要满足顾头不顾腚的原则，所以取不到K元素\r print(a[:5:2]) #加步长print(a[-1:-5:-2]) #反向加步长\r   2.3.2、字符串常用方法。\n字符串除了可以用切片（步长）之外，还有一些其他的操作方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57  #数字符串中的元素出现的个数。\r # ret3 = a1.count(\u0026#34;a\u0026#34;,0,4) # 可切片\r # print(ret3)\r a4 = \u0026#34;dkfjdkfasf54\u0026#34;\r#startswith 判断是否以...开头\r #endswith 判断是否以...结尾\r # ret4 = a4.endswith(\u0026#39;jdk\u0026#39;,3,6) # 顾头不顾腚\r # print(ret4) # 返回的是布尔值\r # ret5 = a4.startswith(\u0026#34;kfj\u0026#34;,1,4)\r # print(ret5)\r #split 以什么分割，最终形成一个列表此列表不含有这个分割的元素。\r # ret9 = \u0026#39;title,Tilte,atre,\u0026#39;.split(\u0026#39;t\u0026#39;)\r # print(ret9)\r # ret91 = \u0026#39;title,Tilte,atre,\u0026#39;.rsplit(\u0026#39;t\u0026#39;,1)\r # print(ret91)\r #format的三种玩法 格式化输出\r res=\u0026#39;{} {} {}\u0026#39;.format(\u0026#39;egon\u0026#39;,18,\u0026#39;male\u0026#39;)\rres=\u0026#39;{1} {0} {1}\u0026#39;.format(\u0026#39;egon\u0026#39;,18,\u0026#39;male\u0026#39;)\rres=\u0026#39;{name} {age} {sex}\u0026#39;.format(sex=\u0026#39;male\u0026#39;,name=\u0026#39;egon\u0026#39;,age=18)\r#strip\r name=\u0026#39;*barry**\u0026#39;\rprint(name.strip(\u0026#39;*\u0026#39;))\rprint(name.lstrip(\u0026#39;*\u0026#39;))\rprint(name.rstrip(\u0026#39;*\u0026#39;))\r#replace\r name=\u0026#39;alex say :i have one tesla,my name is alex\u0026#39;\rprint(name.replace(\u0026#39;alex\u0026#39;,\u0026#39;SB\u0026#39;,1))\r#####is系列\r name=\u0026#39;taibai123\u0026#39;\rprint(name.isalnum()) #字符串由字母或数字组成\r print(name.isalpha()) #字符串只由字母组成\r print(name.isdecimal()) #字符串只由十进制组成\r #############下面这些方法在数据类型补充时会讲到，现在不讲####################\r #寻找字符串中的元素是否存在\r # ret6 = a4.find(\u0026#34;fjdk\u0026#34;,1,6)\r # print(ret6) # 返回的找到的元素的索引，如果找不到返回-1\r # ret61 = a4.index(\u0026#34;fjdk\u0026#34;,4,6)\r # print(ret61) # 返回的找到的元素的索引，找不到报错。\r #captalize,swapcase,title\r print(name.capitalize()) #首字母大写\r print(name.swapcase()) #大小写翻转\r msg=\u0026#39;taibai say hi\u0026#39;\rprint(msg.title()) #每个单词的首字母大写\r # 内同居中，总长度，空白处填充\r ret2 = a1.center(20,\u0026#34;*\u0026#34;)\rprint(ret2)\r  2.4列表list Why: 我们现在已经学过的数据类型有：数字，布尔值，字符串，大家都知道数字主要用于计算，bool值主要是条件判断，只有字符串可以用于数据的存储，这些数据类型够用么？对于一门语言来说，肯定是不够用的。就说字符串：\n1，字符串只能存储少量的数据，对于大量的数据用字符串操作不方便也不易存储。\n2，字符串存储的数据类型太单一，只能是字符串类型。\n例如：‘1 True alex’ 像这样的字符串，我如果通过切片或者其他方法将1 True alex 取出来，他也只能是字符串，但是我想要得到数字的1，布尔值的True，必须还要转化，是不是很麻烦。\n所以python给咱们也提供了一类数据类型，他能承载多种数据类型，这类数据类型被称作容器类数据类型可以存储大量的数据。列表就属于容器类的数据类型。\n**What:**这个数据类型就是list列表。\n列表是python的基础数据类型之一 ,其他编程语言也有类似的数据类型.比如JS中的数 组, java中的数组等等. 它是以[ ]括起来, 每个元素用\u0026rsquo; , \u0026lsquo;隔开而且可以存放各种数据类型: 列表是python中的基础数据类型之一，其他语言中也有类似于列表的数据类\n型，比如js中叫数组，他是以[]括起来，每个元素以逗号隔开，而且他里面可以存放各种数据类型比如：\nli = [‘alex’,123,Ture,(1,2,3,’wusir’),[1,2,3,’小明’,],{‘name’:’alex’}]\n列表相比于字符串，不仅可以储存不同的数据类型，而且可以储存大量数据，32位python的限制是 536870912 个元素,64位python的限制是 1152921504606846975 个元素。而且列表是有序的，有索引值，可切片，方便取值。\nHow：那么这个列表如何使用呢？咱们从这几方面去深入研究这个列表。\n2.4.1 列表的创建\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  # 创建一个列表有三种方式：\r # 方式一：（常用）\r l1 = [1, 2, \u0026#39;太白\u0026#39;]\r# 方式二：（不常用）\r l1 = list() # 空列表\r # l1 = list(iterable) # 可迭代对象\r l1 = list(\u0026#39;123\u0026#39;)\rprint(l1) # [\u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;]\r # 方式三：列表推导式（后面的课程会讲到）\r l1 = [i for i in range(1,5)]\rprint(l1) # [1, 2, 3, 4]\r   2.4.2 列表的索引切片\n1 2 3 4 5 6 7  l1 = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;太白\u0026#39;, 3, 666]\rprint(l1[0]) # \u0026#39;a\u0026#39;\r print(l1[-1]) # 666\r print(l1[1:3]) # [\u0026#39;b\u0026#39;, \u0026#39;太白\u0026#39;]\r print(l1[:-1]) # [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;太白\u0026#39;, 3]\r print(l1[::2]) # [\u0026#39;a\u0026#39;, \u0026#39;太白\u0026#39;, 666]\r print(l1[::-1]) # [666, 3, \u0026#39;太白\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;]\r   相应练习题\n1 2 3 4 5  li = [1, 3, 2, \u0026#34;a\u0026#34;, 4, \u0026#34;b\u0026#34;, 5,\u0026#34;c\u0026#34;]\r通过对li列表的切片形成新的列表l1,l1 = [1,3,2]\r通过对li列表的切片形成新的列表l2,l2 = [\u0026#34;a\u0026#34;,4,\u0026#34;b\u0026#34;]\r通过对li列表的切片形成新的列表l4,l4 = [3,\u0026#34;a\u0026#34;,\u0026#34;b\u0026#34;]\r通过对li列表的切片形成新的列表l6,l6 = [\u0026#34;b\u0026#34;,\u0026#34;a\u0026#34;,3]\r  2.4.3. 增\n列表的增\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  # append 追加，给列表的最后面追加一个元素\r l = [1, 2, \u0026#39;a\u0026#39;]\rl.append(666)\rprint(l) # [1, 2, \u0026#39;a\u0026#39;, 666]\r # insert 插入在列表的任意位置插入元素\r l = [1, 2, \u0026#39;a\u0026#39;]\rl.insert(1,\u0026#39;太白\u0026#39;)\rprint(l) # [1, \u0026#39;太白\u0026#39;, 2, \u0026#39;a\u0026#39;]\r # extend 迭代着追加，在列表的最后面迭代着追加一组数据\r l = [1, 2, \u0026#39;a\u0026#39;]\rl.extend(\u0026#39;太白a\u0026#39;)\rprint(l)\r  2.4.4. 删\n列表的删\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  # pop 通过索引删除列表中对应的元素，该方法有返回值，返回值为删除的元素\r l = [\u0026#39;太白\u0026#39;, \u0026#39;alex\u0026#39;, \u0026#39;WuSir\u0026#39;, \u0026#39;女神\u0026#39;]\rret = l.pop(1)\rprint(ret,l) # alex [\u0026#39;太白\u0026#39;, \u0026#39;WuSir\u0026#39;, \u0026#39;女神\u0026#39;]\r # remove 通过元素删除列表中该元素\r l = [\u0026#39;太白\u0026#39;, \u0026#39;alex\u0026#39;, \u0026#39;WuSir\u0026#39;, \u0026#39;女神\u0026#39;]\rl.remove(\u0026#39;alex\u0026#39;)\rprint(l) # [\u0026#39;太白\u0026#39;, \u0026#39;WuSir\u0026#39;, \u0026#39;女神\u0026#39;]\r # clear 清空列表\r l = [\u0026#39;太白\u0026#39;, \u0026#39;alex\u0026#39;, \u0026#39;WuSir\u0026#39;, \u0026#39;女神\u0026#39;]\rl.clear()\rprint(l) # []  # del\r #按照索引删除该元素\r l = [\u0026#39;太白\u0026#39;, \u0026#39;alex\u0026#39;, \u0026#39;WuSir\u0026#39;, \u0026#39;女神\u0026#39;]\rdel l[2]\rprint(l) # [\u0026#39;太白\u0026#39;, \u0026#39;alex\u0026#39;, \u0026#39;女神\u0026#39;]\r # 切片删除该元素\r l = [\u0026#39;太白\u0026#39;, \u0026#39;alex\u0026#39;, \u0026#39;WuSir\u0026#39;, \u0026#39;女神\u0026#39;]\rdel l[1:]\rprint(l) # [\u0026#39;太白\u0026#39;]\r # 切片(步长)删除该元素\r l = [\u0026#39;太白\u0026#39;, \u0026#39;alex\u0026#39;, \u0026#39;WuSir\u0026#39;, \u0026#39;女神\u0026#39;]\rdel l[::2]\rprint(l) # [\u0026#39;alex\u0026#39;, \u0026#39;女神\u0026#39;]\r   2.4.5. 改\n列表的改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  # 按照索引改值\r l = [\u0026#39;太白\u0026#39;, \u0026#39;alex\u0026#39;, \u0026#39;WuSir\u0026#39;, \u0026#39;女神\u0026#39;]\rl[0] = \u0026#39;男神\u0026#39;\rprint(l) # [\u0026#39;男神\u0026#39;, \u0026#39;alex\u0026#39;, \u0026#39;WuSir\u0026#39;, \u0026#39;女神\u0026#39;]\r # 按照切片改值(迭代着增加)\r l = [\u0026#39;太白\u0026#39;, \u0026#39;alex\u0026#39;, \u0026#39;WuSir\u0026#39;, \u0026#39;女神\u0026#39;]\rl[1:3] = \u0026#39;abcdefg\u0026#39;\rprint(l) # [\u0026#39;太白\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;女神\u0026#39;]  # 按照切片(步长)改值(必须一一对应)\r l = [\u0026#39;太白\u0026#39;, \u0026#39;alex\u0026#39;, \u0026#39;WuSir\u0026#39;, \u0026#39;女神\u0026#39;]\rl[::2] = \u0026#39;对应\u0026#39;\rprint(l) # [\u0026#39;对\u0026#39;, \u0026#39;alex\u0026#39;, \u0026#39;应\u0026#39;, \u0026#39;女神\u0026#39;]\r   2.4.6. 查\n切片去查，或者循环去查。\n2.4.5 其他操作这些方法会在数据类型的补充时再给大家讲~\n2.4.5、其他操作\ncount（数）（方法统计某个元素在列表中出现的次数）。\n1 2  1 a = [\u0026#34;q\u0026#34;,\u0026#34;w\u0026#34;,\u0026#34;q\u0026#34;,\u0026#34;r\u0026#34;,\u0026#34;t\u0026#34;,\u0026#34;y\u0026#34;]\r2 print(a.count(\u0026#34;q\u0026#34;))\r  index（方法用于从列表中找出某个值第一个匹配项的索引位置）\n1 2  1 a = [\u0026#34;q\u0026#34;,\u0026#34;w\u0026#34;,\u0026#34;r\u0026#34;,\u0026#34;t\u0026#34;,\u0026#34;y\u0026#34;]\r2 print(a.index(\u0026#34;r\u0026#34;))\r  sort （方法用于在原位置对列表进行排序）。\nreverse （方法将列表中的元素反向存放）。\n1 2 3 4 5  1 a = [2,1,3,4,5]\r2 a.sort()# 他没有返回值，所以只能打印a\r 3 print(a)\r4 a.reverse()#他也没有返回值，所以只能打印a\r 5 print(a)\r  列表也可以相加与整数相乘\n1 2 3 4  l1 = [1, 2, 3]\rl2 = [4, 5, 6]\r# print(l1+l2) # [1, 2, 3, 4, 5, 6]\r print(l1*3) # [1, 2, 3, 1, 2, 3, 1, 2, 3]\r   相应练习题\n1 2 3 4 5 6 7 8 9 10  li = [\u0026#34;alex\u0026#34;, \u0026#34;WuSir\u0026#34;, \u0026#34;ritian\u0026#34;, \u0026#34;barry\u0026#34;, \u0026#34;wenzhou\u0026#34;]\r计算列表的长度并输出\r列表中追加元素\u0026#34;seven\u0026#34;,并输出添加后的列表\r请在列表的第1个位置插入元素\u0026#34;Tony\u0026#34;,并输出添加后的列表\r请修改列表第2个位置的元素为\u0026#34;Kelly\u0026#34;,并输出修改后的列表\r请将列表l2=[1,\u0026#34;a\u0026#34;,3,4,\u0026#34;heart\u0026#34;]的每一个元素添加到列表li中，一行代码实现，不允许循环添加。\r请将字符串s = \u0026#34;qwert\u0026#34;的每一个元素添加到列表li中，一行代码实现，不允许循环添加。\r请删除列表中的元素\u0026#34;ritian\u0026#34;,并输出添加后的列表\r请删除列表中的第2个元素，并输出删除的元素和删除元素后的列表\r请删除列表中的第2至4个元素，并输出删除元素后的列表\r  2.4.6 列表的嵌套\n1 2 3 4  l1 = [1, 2, \u0026#39;taibai\u0026#39;, [1, \u0026#39;WuSir\u0026#39;, 3,]]\r1, 将l1中的\u0026#39;taibai\u0026#39;变成大写并放回原处。\r2，给小列表[1,\u0026#39;alex\u0026#39;,3,]追加一个元素,\u0026#39;老男孩教育\u0026#39;。\r3，将列表中的\u0026#39;alex\u0026#39;通过字符串拼接的方式在列表中变成\u0026#39;alexsb\u0026#39;\r  相应练习题\n1 2 3 4  lis = [2, 3, \u0026#34;k\u0026#34;, [\u0026#34;qwe\u0026#34;, 20, [\u0026#34;k1\u0026#34;, [\u0026#34;tt\u0026#34;, 3, \u0026#34;1\u0026#34;]], 89], \u0026#34;ab\u0026#34;, \u0026#34;adv\u0026#34;]\r将列表lis中的\u0026#34;tt\u0026#34;变成大写（用两种方式）。\r将列表中的数字3变成字符串\u0026#34;100\u0026#34;（用两种方式）。\r将列表中的字符串\u0026#34;1\u0026#34;变成数字101（用两种方式）。\r  2.5元组tuple。 Why:对于容器型数据类型list，无论谁都可以对其增删改查，那么有一些重要的数据放在list中是不安全的，所以需要一种容器类的数据类型存放重要的数据，创建之初只能查看而不能增删改，这种数据类型就是元组。\nwhat:这个容器型数据类型就是元组。\n元组:俗称不可变的列表,又被成为只读列表,元祖也是python的基本数据类型之一,用小括号括起来,里面可以放任何数据类型的数据,查询可以,循环也可以,切片也可以.但就是不能改.\n2.5.1 元组的索引切片\n1 2 3 4 5 6 7  tu1 = (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;太白\u0026#39;, 3, 666)\rprint(tu1[0]) # \u0026#39;a\u0026#39;\r print(tu1[-1]) # 666\r print(tu1[1:3]) # (\u0026#39;b\u0026#39;, \u0026#39;太白\u0026#39;)\r print(tu1[:-1]) # (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;太白\u0026#39;, 3)\r print(tu1[::2]) # (\u0026#39;a\u0026#39;, \u0026#39;太白\u0026#39;, 666)\r print(tu1[::-1]) # (666, 3, \u0026#39;太白\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;a\u0026#39;\r   2.5.2 元组其他操作方法\n因为元组的特性，直接从属于元组的元素不能更改，所以元组只能查看。\n1 2 3 4 5  # 可以利用for循环查询\r tu1 = (\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;太白\u0026#39;, 3, 666)\rfor i in tu1:\rprint(i)\r  index：通过元素找索引（可切片），找到第一个元素就返回，找不到该元素即报错。\n1 2  tu = (\u0026#39;太白\u0026#39;, [1, 2, 3, ], \u0026#39;WuSir\u0026#39;, \u0026#39;女神\u0026#39;)\rprint(tu.index(\u0026#39;太白\u0026#39;)) # 0\r   count: 获取某元素在列表中出现的次数\n1 2  tu = (\u0026#39;太白\u0026#39;, \u0026#39;太白\u0026#39;, \u0026#39;WuSir\u0026#39;, \u0026#39;吴超\u0026#39;)\rprint(tu.count(\u0026#39;太白\u0026#39;)) # 2\r   2.5.3 len\n1 2 3 4 5  tu1 = (1,2,3,4,84,5,2,8,2,11,88,2)\rprint(len(tu1))\r结果:\r12　  2.6字典dict。 　2.6.1 字典的初识\n**Why:**咱们目前已经学习到的容器型数据类型只有list，那么list够用？他有什么缺点呢？\n\\1. 列表可以存储大量的数据类型，但是如果数据量大的话，他的查询速度比较慢。\n\\2. 列表只能按照顺序存储，数据与数据之间关联性不强。\n所以针对于上的缺点，说咱们需要引入另一种容器型的数据类型，解决上面的问题，这就需要dict字典。\nwhat：\n数据类型可以按照多种角度进行分类，就跟咱们人一样，人按照地域可以划分分为亚洲人，欧洲人，美洲人等，但是按照肤色又可以分为白种人，黄种人，黑种人，等等，数据类型可以按照不同的角度进行分类，先给大家按照可变与不可变的数据类型的分类：\n不可变（可哈希）的数据类型：int，str，bool，tuple。\n可变（不可哈希）的数据类型：list，dict，set。\n字典是Python语言中的映射类型，他是以{}括起来，里面的内容是以键值对的形式储存的：\nKey: 不可变（可哈希）的数据类型.并且键是唯一的，不重复的。\nValue:任意数据(int，str，bool，tuple，list，dict，set)，包括后面要学的实例对象等。\n　在Python3.5版本（包括此版本）之前，字典是无序的。\n　在Python3.6版本之后，字典会按照初建字典时的顺序排列(即第一次插入数据的顺序排序)。\n　当然，字典也有缺点：他的缺点就是内存消耗巨大。\n2.6.2 创建字典的几种方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  # 创建字典的几种方式：\r # 方式1:\r dic = dict(((\u0026#39;one\u0026#39;, 1),(\u0026#39;two\u0026#39;, 2),(\u0026#39;three\u0026#39;, 3)))\r# dic = dict([(\u0026#39;one\u0026#39;, 1),(\u0026#39;two\u0026#39;, 2),(\u0026#39;three\u0026#39;, 3)])\r print(dic) # {\u0026#39;one\u0026#39;: 1, \u0026#39;two\u0026#39;: 2, \u0026#39;three\u0026#39;: 3}\r # 方式2:\r dic = dict(one=1,two=2,three=3)\rprint(dic) # {\u0026#39;one\u0026#39;: 1, \u0026#39;two\u0026#39;: 2, \u0026#39;three\u0026#39;: 3}\r # 方式3:\r dic = dict({\u0026#39;one\u0026#39;: 1, \u0026#39;two\u0026#39;: 2, \u0026#39;three\u0026#39;: 3})\rprint(dic) # {\u0026#39;one\u0026#39;: 1, \u0026#39;two\u0026#39;: 2, \u0026#39;three\u0026#39;: 3}\r # 方式5: 后面会讲到先了解\r dic = dict(zip([\u0026#39;one\u0026#39;, \u0026#39;two\u0026#39;, \u0026#39;three\u0026#39;],[1, 2, 3]))\rprint(dic)\r# 方式6: 字典推导式 后面会讲到\r # dic = { k: v for k,v in [(\u0026#39;one\u0026#39;, 1),(\u0026#39;two\u0026#39;, 2),(\u0026#39;three\u0026#39;, 3)]}\r # print(dic)\r # 方式7:利用fromkey后面会讲到。\r # dic = dict.fromkeys(\u0026#39;abcd\u0026#39;,\u0026#39;太白\u0026#39;)\r # print(dic) # {\u0026#39;a\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;b\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;c\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;d\u0026#39;: \u0026#39;太白\u0026#39;}\r   2.6.3 验证字典的合法性\n1 2 3 4 5 6 7 8 9 10 11 12 13  # 合法\r dic = {123: 456, True: 999, \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#39;sylar\u0026#39;, \u0026#34;age\u0026#34;: 18, \u0026#34;stu\u0026#34;: [\u0026#39;帅\r 哥\u0026#39;, \u0026#39;美⼥\u0026#39;], (1, 2, 3): \u0026#39;麻花藤\u0026#39;}\r print(dic[123])\rprint(dic[True])\rprint(dic[\u0026#39;id\u0026#39;])\rprint(dic[\u0026#39;stu\u0026#39;])\rprint(dic[(1, 2, 3)])\r# 不合法\r # dic = {[1, 2, 3]: \u0026#39;周杰伦\u0026#39;} # list是可变的. 不能作为key\r # dic = {{1: 2}: \u0026#34;哈哈哈\u0026#34;} # dict是可变的. 不能作为key\r dic = {{1, 2, 3}: \u0026#39;呵呵呵\u0026#39;} # set是可变的, 不能作为key\r   2.6.4 字典的常用操作方法\n增\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  # 通过键值对直接增加\r dic = {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;age\u0026#39;: 18}\rdic[\u0026#39;weight\u0026#39;] = 75 # 没有weight这个键，就增加键值对\r print(dic) # {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;age\u0026#39;: 18, \u0026#39;weight\u0026#39;: 75}\r dic[\u0026#39;name\u0026#39;] = \u0026#39;barry\u0026#39; # 有name这个键，就成了字典的改值\r print(dic) # {\u0026#39;name\u0026#39;: \u0026#39;barry\u0026#39;, \u0026#39;age\u0026#39;: 18, \u0026#39;weight\u0026#39;: 75}\r # setdefault\r dic = {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;age\u0026#39;: 18}\rdic.setdefault(\u0026#39;height\u0026#39;,175) # 没有height此键，则添加\r print(dic) # {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;age\u0026#39;: 18, \u0026#39;height\u0026#39;: 175}\r dic.setdefault(\u0026#39;name\u0026#39;,\u0026#39;barry\u0026#39;) # 有此键则不变\r print(dic) # {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;age\u0026#39;: 18, \u0026#39;height\u0026#39;: 175}\r #它有返回值\r dic = {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;age\u0026#39;: 18}\rret = dic.setdefault(\u0026#39;name\u0026#39;)\rprint(ret) # 太白\r   删\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  # pop 通过key删除字典的键值对，有返回值，可设置返回值。\r dic = {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;age\u0026#39;: 18}\r# ret = dic.pop(\u0026#39;name\u0026#39;)\r # print(ret,dic) # 太白 {\u0026#39;age\u0026#39;: 18}\r ret1 = dic.pop(\u0026#39;n\u0026#39;,None)\rprint(ret1,dic) # None {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;age\u0026#39;: 18}\r #popitem 3.5版本之前，popitem为随机删除，3.6之后为删除最后一个，有返回值\r dic = {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;age\u0026#39;: 18}\rret = dic.popitem()\rprint(ret,dic) # (\u0026#39;age\u0026#39;, 18) {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;}\r #clear 清空字典\r dic = {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;age\u0026#39;: 18}\rdic.clear()\rprint(dic) # {}\r # del\r # 通过键删除键值对\r dic = {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;age\u0026#39;: 18}\rdel dic[\u0026#39;name\u0026#39;]\rprint(dic) # {\u0026#39;age\u0026#39;: 18}\r #删除整个字典\r del dic\r  改\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  # 通过键值对直接改\r dic = {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;age\u0026#39;: 18}\rdic[\u0026#39;name\u0026#39;] = \u0026#39;barry\u0026#39;\rprint(dic) # {\u0026#39;name\u0026#39;: \u0026#39;barry\u0026#39;, \u0026#39;age\u0026#39;: 18}\r # update\r dic = {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;age\u0026#39;: 18}\rdic.update(sex=\u0026#39;男\u0026#39;, height=175)\rprint(dic) # {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;age\u0026#39;: 18, \u0026#39;sex\u0026#39;: \u0026#39;男\u0026#39;, \u0026#39;height\u0026#39;: 175}\r dic = {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;age\u0026#39;: 18}\rdic.update([(1, \u0026#39;a\u0026#39;),(2, \u0026#39;b\u0026#39;),(3, \u0026#39;c\u0026#39;),(4, \u0026#39;d\u0026#39;)])\rprint(dic) # {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;age\u0026#39;: 18, 1: \u0026#39;a\u0026#39;, 2: \u0026#39;b\u0026#39;, 3: \u0026#39;c\u0026#39;, 4: \u0026#39;d\u0026#39;}\r dic1 = {\u0026#34;name\u0026#34;:\u0026#34;jin\u0026#34;,\u0026#34;age\u0026#34;:18,\u0026#34;sex\u0026#34;:\u0026#34;male\u0026#34;}\rdic2 = {\u0026#34;name\u0026#34;:\u0026#34;alex\u0026#34;,\u0026#34;weight\u0026#34;:75}\rdic1.update(dic2)\rprint(dic1) # {\u0026#39;name\u0026#39;: \u0026#39;alex\u0026#39;, \u0026#39;age\u0026#39;: 18, \u0026#39;sex\u0026#39;: \u0026#39;male\u0026#39;, \u0026#39;weight\u0026#39;: 75}\r print(dic2) # {\u0026#39;name\u0026#39;: \u0026#39;alex\u0026#39;, \u0026#39;weight\u0026#39;: 75}    查\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  # 通过键查询\r # 直接dic[key](没有此键会报错)\r dic = {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;age\u0026#39;: 18}\rprint(dic[\u0026#39;name\u0026#39;]) # 太白\r # get\r dic = {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;age\u0026#39;: 18}\rv = dic.get(\u0026#39;name\u0026#39;)\rprint(v) # \u0026#39;太白\u0026#39;\r v = dic.get(\u0026#39;name1\u0026#39;)\rprint(v) # None\r v = dic.get(\u0026#39;name2\u0026#39;,\u0026#39;没有此键\u0026#39;)\rprint(v) # 没有此键  keys()\rdic = {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;age\u0026#39;: 18}\rprint(dic.keys()) # dict_keys([\u0026#39;name\u0026#39;, \u0026#39;age\u0026#39;])  values()\rdic = {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;age\u0026#39;: 18}\rprint(dic.values()) # dict_values([\u0026#39;太白\u0026#39;, 18])\r items()\rdic = {\u0026#39;name\u0026#39;: \u0026#39;太白\u0026#39;, \u0026#39;age\u0026#39;: 18}\rprint(dic.items()) # dict_items([(\u0026#39;name\u0026#39;, \u0026#39;太白\u0026#39;), (\u0026#39;age\u0026#39;, 18)])\r   相关练习题\n1 2 3 4 5  dic = {\u0026#39;k1\u0026#39;: \u0026#34;v1\u0026#34;, \u0026#34;k2\u0026#34;: \u0026#34;v2\u0026#34;, \u0026#34;k3\u0026#34;: [11,22,33]}\r请在字典中添加一个键值对，\u0026#34;k4\u0026#34;: \u0026#34;v4\u0026#34;，输出添加后的字典\r请在修改字典中 \u0026#34;k1\u0026#34; 对应的值为 \u0026#34;alex\u0026#34;，输出修改后的字典\r请在k3对应的值中追加一个元素 44，输出修改后的字典\r请在k3对应的值的第 1 个位置插入个元素 18，输出修改后的字典\r  fromkeys 数据类型\ndic = dict.fromkeys('abcd','太白')\rprint(dic) # {'a': '太白', 'b': '太白', 'c': '太白', 'd': '太白'}\rdic = dict.fromkeys([1, 2, 3],'太白')\rprint(dic) # {1: '太白', 2: '太白', 3: '太白'} 其他操作\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  key_list = dic.keys() print(key_list)\r结果:\rdict_keys([\u0026#39;剑圣\u0026#39;, \u0026#39;哈啥给\u0026#39;, \u0026#39;大宝剑\u0026#39;])\r# 一个高仿列表,存放的都是字典中的key\r # 并且这个高仿的列表可以转化成列表\r print(list(key_list))\r# 它还可以循环打印\r dic = {\u0026#39;剑圣\u0026#39;:\u0026#39;易\u0026#39;,\u0026#39;哈啥给\u0026#39;:\u0026#39;剑豪\u0026#39;,\u0026#39;大宝剑\u0026#39;:\u0026#39;盖伦\u0026#39;}\rfor i in dic:\rprint(i)\rvalue_list = dic.values()\rprint(value_list)\r结果:\rdict_values([\u0026#39;易\u0026#39;, \u0026#39;剑豪\u0026#39;, \u0026#39;盖伦\u0026#39;])\r#一个高仿列表,存放都是字典中的value\r # 并且这个高仿的列表可以转化成列表\r print(list(value_list))\r# 它还可以循环打印\r for i in dic.values(): print(i)\rkey_value_list = dic.items()\rprint(key_value_list)\r结果:\rdict_items([(\u0026#39;剑圣\u0026#39;, \u0026#39;易\u0026#39;), (\u0026#39;哈啥给\u0026#39;, \u0026#39;剑豪\u0026#39;), (\u0026#39;大宝剑\u0026#39;, \u0026#39;盖伦\u0026#39;)])\r# 一个高仿列表,存放是多个元祖,元祖中第一个是字典中的键,第二个是字典中的值　 # 并且这个高仿的列表可以转化成列表\r print(list(key_value_list ))\r# 它还可以循环打印\r dic = {\u0026#39;剑圣\u0026#39;:\u0026#39;易\u0026#39;,\u0026#39;哈啥给\u0026#39;:\u0026#39;剑豪\u0026#39;,\u0026#39;大宝剑\u0026#39;:\u0026#39;盖伦\u0026#39;}\rfor i in dic.items():\rprint(i)\r结果：\r(\u0026#39;剑圣\u0026#39;, \u0026#39;易\u0026#39;)\r(\u0026#39;哈啥给\u0026#39;, \u0026#39;剑豪\u0026#39;)\r(\u0026#39;大宝剑\u0026#39;, \u0026#39;盖伦\u0026#39;)\r  分别赋值，也叫拆包。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  a,b = 1,2\rprint(a,b)\r结果:\r1 2\ra,b = (\u0026#39;你好\u0026#39;,\u0026#39;世界\u0026#39;) # 这个用专业名词就叫做元组的拆包\r print(a,b)\r结果:\r你好 世界\ra,b = [\u0026#39;你好\u0026#39;,\u0026#39;大飞哥\u0026#39;]\rprint(a,b)\r结果:\r你好 大飞哥\ra,b = {\u0026#39;汪峰\u0026#39;:\u0026#39;北京北京\u0026#39;,\u0026#39;王菲\u0026#39;:\u0026#39;天后\u0026#39;}\rprint(a,b)\r结果:\r汪峰 王菲\r  所以利用上面刚学的拆包的概念，我们循环字典时还可以这样获取字典的键，以及值：\n4.1.5字典的嵌套\n字典的嵌套是非常重要的知识点，这个必须要建立在熟练使用字典的增删改查的基础上，而且字典的嵌套才是咱们在工作中经常会遇到的字典，工作中遇到的字典不是简简单单一层，而就像是葱头一样，一层接一层，但一般都是很有规律的嵌套，那么接下来我们就学习一下字典的嵌套：\n现在有如下字典，完成一下需求：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  dic = {\r\u0026#39;name\u0026#39;:\u0026#39;汪峰\u0026#39;,\r\u0026#39;age\u0026#39;:48,\r\u0026#39;wife\u0026#39;:[{\u0026#39;name\u0026#39;:\u0026#39;国际章\u0026#39;,\u0026#39;age\u0026#39;:38}],\r\u0026#39;children\u0026#39;:{\u0026#39;girl_first\u0026#39;:\u0026#39;小苹果\u0026#39;,\u0026#39;girl_second\u0026#39;:\u0026#39;小怡\u0026#39;,\u0026#39;girl_three\u0026#39;:\u0026#39;顶顶\u0026#39;}\r}\r1. 获取汪峰的名字。\r2.获取这个字典：{\u0026#39;name\u0026#39;:\u0026#39;国际章\u0026#39;,\u0026#39;age\u0026#39;:38}。\r3. 获取汪峰妻子的名字。\r4. 获取汪峰的第三个孩子名字。\r  相关练习题\n1 2 3 4 5 6 7 8 9  dic1 = {\r\u0026#39;name\u0026#39;:[\u0026#39;alex\u0026#39;,2,3,5],\r\u0026#39;job\u0026#39;:\u0026#39;teacher\u0026#39;,\r\u0026#39;oldboy\u0026#39;:{\u0026#39;alex\u0026#39;:[\u0026#39;python1\u0026#39;,\u0026#39;python2\u0026#39;,100]}\r}\r1，将name对应的列表追加⼀个元素’wusir’。\r2，将name对应的列表中的alex⾸字⺟⼤写。\r3，oldboy对应的字典加⼀个键值对’⽼男孩’,’linux’。\r4，将oldboy对应的字典中的alex对应的列表中的python2删除\r  2.7集合set (了解) 集合是无序的，不重复的数据集合，它里面的元素是可哈希的(不可变类型)，但是集合本身是不可哈希（所以集合做不了字典的键）的。以下是集合最重要的两点：\n　去重，把一个列表变成集合，就自动去重了。\n　关系测试，测试两组数据之前的交集、差集、并集等关系。\n1，集合的创建。\n1 2 3  set1 = set({1,2,\u0026#39;barry\u0026#39;})\rset2 = {1,2,\u0026#39;barry\u0026#39;}\rprint(set1,set2) # {1, 2, \u0026#39;barry\u0026#39;} {1, 2, \u0026#39;barry\u0026#39;}\r   2，集合的增。\n1 2 3 4 5 6 7 8 9 10 11  set1 = {\u0026#39;alex\u0026#39;,\u0026#39;wusir\u0026#39;,\u0026#39;ritian\u0026#39;,\u0026#39;egon\u0026#39;,\u0026#39;barry\u0026#39;}\rset1.add(\u0026#39;景女神\u0026#39;)\rprint(set1)\r#update：迭代着增加\r set1.update(\u0026#39;A\u0026#39;)\rprint(set1)\rset1.update(\u0026#39;老师\u0026#39;)\rprint(set1)\rset1.update([1,2,3])\rprint(set1)\r  3，集合的删。\n1 2 3 4 5 6 7 8 9 10 11 12 13  set1 = {\u0026#39;alex\u0026#39;,\u0026#39;wusir\u0026#39;,\u0026#39;ritian\u0026#39;,\u0026#39;egon\u0026#39;,\u0026#39;barry\u0026#39;}\rset1.remove(\u0026#39;alex\u0026#39;) # 删除一个元素\r print(set1)\rset1.pop() # 随机删除一个元素\r print(set1)\rset1.clear() # 清空集合\r print(set1)\rdel set1 # 删除集合\r print(set1)\r  4，集合的其他操作：\n　4.1 交集。（\u0026amp; 或者 intersection）\n1 2 3 4  set1 = {1,2,3,4,5}\rset2 = {4,5,6,7,8}\rprint(set1 \u0026amp; set2) # {4, 5}\r print(set1.intersection(set2)) # {4, 5}\r   　4.2 并集。（| 或者 union）\n1 2 3  set1 = {1,2,3,4,5}\rset2 = {4,5,6,7,8}\rprint(set1 | set2) # {1, 2, 3, 4, 5, 6, 7,8}print(set2.union(set1)) # {1, 2, 3, 4, 5, 6, 7,8}\r   　4.3 差集。（- 或者 difference）\n1 2 3 4  set1 = {1,2,3,4,5}\rset2 = {4,5,6,7,8}\rprint(set1 - set2) # {1, 2, 3}\r print(set1.difference(set2)) # {1, 2, 3}\r   　4.4反交集。 （^ 或者 symmetric_difference）\n1 2 3 4  set1 = {1,2,3,4,5}\rset2 = {4,5,6,7,8}\rprint(set1 ^ set2) # {1, 2, 3, 6, 7, 8}\r print(set1.symmetric_difference(set2)) # {1, 2, 3, 6, 7, 8}\r   　4.5子集与超集\n1 2 3 4 5 6 7 8  set1 = {1,2,3}\rset2 = {1,2,3,4,5,6}\rprint(set1 \u0026lt; set2)\rprint(set1.issubset(set2)) # 这两个相同，都是说明set1是set2子集。\r print(set2 \u0026gt; set1)\rprint(set2.issuperset(set1)) # 这两个相同，都是说明set2是set1超集。\r   5，frozenset不可变集合，让集合变成不可变类型。\n1 2  s = frozenset(\u0026#39;barry\u0026#39;)\rprint(s,type(s)) # frozenset({\u0026#39;a\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;r\u0026#39;}) \u0026lt;class \u0026#39;frozenset\u0026#39;\u0026gt;\r   三.其他（for，enumerate，range）。 for循环：用户按照顺序循环可迭代对象的内容。\n1 2 3 4 5 6 7 8 9 10 11  msg = \u0026#39;老男孩python是全国范围内最好的python培训机构\u0026#39;\rfor item in msg:\rprint(item)\rli = [\u0026#39;alex\u0026#39;,\u0026#39;银角\u0026#39;,\u0026#39;女神\u0026#39;,\u0026#39;egon\u0026#39;,\u0026#39;太白\u0026#39;]\rfor i in li:\rprint(i)\rdic = {\u0026#39;name\u0026#39;:\u0026#39;太白\u0026#39;,\u0026#39;age\u0026#39;:18,\u0026#39;sex\u0026#39;:\u0026#39;man\u0026#39;}\rfor k,v in dic.items():\rprint(k,v)\r  enumerate：枚举，对于一个可迭代的（iterable）/可遍历的对象（如列表、字符串），enumerate将其组成一个索引序列，利用它可以同时获得索引和值。\n1 2 3 4 5 6 7  li = [\u0026#39;alex\u0026#39;,\u0026#39;银角\u0026#39;,\u0026#39;女神\u0026#39;,\u0026#39;egon\u0026#39;,\u0026#39;太白\u0026#39;]\rfor i in enumerate(li):\rprint(i)\rfor index,name in enumerate(li,1):\rprint(index,name)\rfor index, name in enumerate(li, 100): # 起始位置默认是0，可更改\r print(index, name)　  range：指定范围，生成指定数字。\n1 2 3 4 5 6 7 8  for i in range(1,10):\rprint(i)\rfor i in range(1,10,2): # 步长\r print(i)\rfor i in range(10,1,-2): # 反向步长\r print(i)\r  ","description":"","id":25,"section":"posts","tags":null,"title":"","uri":"https://ymmeng.github.io/zh/posts/python/python%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"content":"一. 格式化输出 1 2 3 4 5 6 7 8  info = \u0026#39;\u0026#39;\u0026#39;\r------------ info of %s----------- #这里的每个%s就是一个占位符，本行的代表 后面拓号里的 name Name : %s#代表 name Age : %s#代表 age job : %s#代表 job Hobbie: %s#代表 hobbie ------------- end -----------------\r\u0026#39;\u0026#39;\u0026#39; %(name,name,age,job,hobbie) # 这行的 % 号就是 把前面的字符串 与拓号 后面的 变量 关联起来     %s就是代表字符串占位符，除此之外，还有%d,是数字占位符， 如果把上面的age后面的换成%d，就代表你必须只能输入数字啦  二. 流程控制之\u0026ndash;while循环 2.1,基本循环 while` `条件:\r``# 循环体\r``# 如果条件为真，那么循环体则执行\r``# 如果条件为假，那么循环体不执行\r2.2 演示生活中循环听歌 while True:\rprint('痒')\rprint('社会摇')\rprint('喜洋洋')\rprint('我要这铁棒有何用')\r 那么大家都看到了，while循环他的执行结果就是这样一直循环，只要电脑不死机，直至天荒地老\u0026hellip;\u0026hellip;. 他的内部是怎么执行的呢？  2.3 如何终止循环？  改变条件(根据上面的流程，只要改变条件，就会终止循环)。 关键字：break。 调用系统命令：quit(),exit() 后面会讲到，不建议大家使用。 关键字：continue（终止本次循环）。  　**2.3.1 终止循环的第一个方法：**利用改变条件，终止循环。给大家引入标志位的概念。\n1 2 3 4 5 6 7  flag = True\rwhile flag:\rprint(\u0026#39;痒\u0026#39;)\rprint(\u0026#39;社会摇\u0026#39;)\rprint(\u0026#39;喜洋洋\u0026#39;)\rflag = False\rprint(\u0026#39;我要这铁棒有何用\u0026#39;)\r  练习1:输出1~100所有的数字\n1 2 3 4 5 6 7  count = 1\rflag = True\rwhile flag:\rprint(count)\rcount = count + 1\rif count == 101:\rflag = False\r  练习2：使用while循环求出1-100所有数的和.\n1 2 3 4 5 6 7 8 9 10  \u0026#39;\u0026#39;\u0026#39;\r思路：你要想从1+2+3......+100一直加到100，那么最起码你得有一个自变量，比如count，这个count每次循环都会自加1，除了这个之外，你还有有一个变量，让这个变量一直去加这个count，这个基础变量还不能影响最终的结果，所以这个基础变量初始值为0，按照这个思路写一下。\r\u0026#39;\u0026#39;\u0026#39;\rcount = 1\rs = 0\rwhile count \u0026lt; 101:\rs = s + count\rcount = count + 1\rprint(s)\r  2.3.2 终止循环的第二方法：break\n　break：很简单，就是Python给大家提供的关键字，什么是关键字？就是python中具有一定特殊意义的单词，比如if，str，int等，这些不能用作变量对吧？\n​ 那么break的用法是什么？ 即：循环中，只要遇到break马上退出循环。举例说明：\n1 2 3 4 5 6 7 8 9  flag = True\rprint(111)\rwhile flag:\rprint(\u0026#39;痒\u0026#39;)\rprint(\u0026#39;社会摇\u0026#39;)\rprint(\u0026#39;喜洋洋\u0026#39;)\rbreak\rprint(\u0026#39;我要这铁棒有何用\u0026#39;)\rprint(222)\r  练习3：打印1~100所有的偶数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  \u0026#39;\u0026#39;\u0026#39;\r思路：所有的偶数，偶数有什么特点？ 对2取余为0，取余在python中用%表示。再循环时，你要先打印出1~100所有的数，会吧？ 在这个基础上加以改动：当count为偶数时打印，否则什么操作都不做。\r\u0026#39;\u0026#39;\u0026#39;\r# 方法一：\r count = 1\rwhile True:\rif count % 2 == 0:\rprint(count)\rcount = count + 1\rif count == 101:\rbreak\r# 方法二:\r count = 1\rwhile count \u0026lt; 101:\rif count % 2 == 0:\rprint(count)\rcount = count + 1\r# 方法三:\r count = 2\rwhile count \u0026lt; 101:\rprint(count)\rcount = count + 2\r  2.3.3 终止循环的第三个方法：今天先不讲了，后面会给大家补充。\n2.3.4 continue\n​ continue 用于终止本次循环，继续下一次循环。举例说明：\n1 2 3 4 5 6 7 8 9  flag = True\rprint(111)\rwhile flag:\rprint(\u0026#39;痒\u0026#39;)\rprint(\u0026#39;社会摇\u0026#39;)\rprint(\u0026#39;喜洋洋\u0026#39;)\rcontinue\rprint(\u0026#39;我要这铁棒有何用\u0026#39;)\rprint(222)\r  2.4,while \u0026hellip; else .. 与其它语言else 一般只与if 搭配不同，在Python 中还有个while \u0026hellip;else 语句\nwhile 后面的else 作用是指，当while 循环正常执行完，中间没有被break 中止的话，就会执行else后面的语句\n1 2 3 4 5 6 7 8  count = 0\rwhile count \u0026lt;= 5 :\rcount += 1\rprint(\u0026#34;Loop\u0026#34;,count)\relse:\rprint(\u0026#34;循环正常执行完啦\u0026#34;)\rprint(\u0026#34;-----out of while loop ------\u0026#34;)\r  输出\n1 2 3 4 5 6 7 8  Loop 1\rLoop 2\rLoop 3\rLoop 4\rLoop 5\rLoop 6\r循环正常执行完啦\r-----out of while loop ------\r  如果执行过程中被break啦，就不会执行else的语句啦\n1 2 3 4 5 6 7 8 9  count = 0\rwhile count \u0026lt;= 5 :\rcount += 1\rif count == 3:break\rprint(\u0026#34;Loop\u0026#34;,count)\relse:\rprint(\u0026#34;循环正常执行完啦\u0026#34;)\rprint(\u0026#34;-----out of while loop ------\u0026#34;)\r  输出\n1 2 3  Loop 1\rLoop 2\r-----out of while loop ------\r  三. 基本运算符 运算符\n　计算机可以进行的运算有很多种，可不只加减乘除这么简单，运算按种类可分为算数运算、比较运算、逻辑运算、赋值运算、成员运算、身份运算、位运算，今天我们暂只学习算数运算、比较运算、逻辑运算、赋值运算、成员运算\n算数运算\n以下假设变量：a=10，b=20\n比较运算\n以下假设变量：a=10，b=20\n赋值运算\n以下假设变量：a=10，b=20\n逻辑运算\n针对逻辑运算的进一步研究：\n　1,在没有()的情况下not 优先级高于 and，and优先级高于or，即优先级关系为( )\u0026gt;not\u0026gt;and\u0026gt;or，同一优先级从左往右计算。\n例题：\n判断下列逻辑语句的True，False。\n1 2 3 4 5  1,3\u0026gt;4 or 4\u0026lt;3 and 1==1\r2,1 \u0026lt; 2 and 3 \u0026lt; 4 or 1\u0026gt;2 3,2 \u0026gt; 1 and 3 \u0026lt; 4 or 4 \u0026gt; 5 and 2 \u0026lt; 1\r4,1 \u0026gt; 2 and 3 \u0026lt; 4 or 4 \u0026gt; 5 and 2 \u0026gt; 1 or 9 \u0026lt; 8\r5,1 \u0026gt; 1 and 3 \u0026lt; 4 or 4 \u0026gt; 5 and 2 \u0026gt; 1 and 9 \u0026gt; 8 or 7 \u0026lt; 66,not 2 \u0026gt; 1 and 3 \u0026lt; 4 or 4 \u0026gt; 5 and 2 \u0026gt; 1 and 9 \u0026gt; 8 or 7 \u0026lt; 6\r  　2 , x or y , x为真，值就是x，x为假，值是y；\n​ x and y, x为真，值是y,x为假，值是x。**\n**\n　例题：求出下列逻辑语句的值。\n8 or 4\r0 and 3\r0 or 4 and 3 or 7 or 9 and 6\r成员运算：\n除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。\n判断子元素是否在原字符串（字典，列表，集合）中：\n例如：\n#print('喜欢' in 'dkfljadklf喜欢hfjdkas')\r#print('a' in 'bcvd')\r#print('y' not in 'ofkjdslaf')\rPython运算符优先级\n以下表格列出了从最高到最低优先级的所有运算符：\n   运算符 描述     ** 指数 (最高优先级)   ~ + - 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@)   * / % // 乘，除，取模和取整除   + - 加法减法   \u0026raquo; \u0026laquo; 右移，左移运算符   \u0026amp; 位 \u0026lsquo;AND\u0026rsquo;   ^ | 位运算符   \u0026lt;= \u0026lt; \u0026gt; \u0026gt;= 比较运算符   \u0026lt;\u0026gt; == != 等于运算符   = %= /= //= -= += *= **= 赋值运算符   is is not 身份运算符   in not in 成员运算符   not and or 逻辑运算符    四. 编码的初识 咱们都看过谍战片吧？是不是都看过发电报的场景？电报发的是什么？滴滴滴，滴滴。是不是高低电平？\n在回到咱们的电脑上，咱们的电脑，存储和发送文件，发送的是什么？电脑里面是不是有成千上万个二极管，亮的代表是1，不亮的代表是0，这样实际上电脑的存储和发送是不是都是010101？\n来找个同学，咱们模拟一下谍战时期的情景：\n我发给你一句话：今晚嗨去呀？\n前提是不是需要一个对照本？010101 代表什么文字？\n今 01\n晚 101\n嗨 00111\n去 1001\n这样我给你发过去你能看懂么？\n011010001111001\n是不是应该断句？规定几个01是一个文字？\n所以我规定了八位为一段，\n今 0000 0001\n晚 0000 0101\n嗨 0000 0111\n去 0000 1001\n00000001 00000101 00000111 00001001\n这样，你就能明白了，所以asiic码就相当于这个密码本,这个密码本记录的就是0101010 与 文字之间的对应关系。\n那么咱们重新捋顺序一遍：\n计算机是需要存储数据和通过网络传输数据的，计算机存储在磁盘中的数据或者通过网络发送的数据本质发送的都是bit流也就是所谓的01010101101，那么这些010010是需要与咱们熟知的文字有标准的对应关系，这样咱们才可以识别这些数据。\n计算机起初使用的密码本是：ASCII码（American Standard Code for Information Interchange，美国标准信息交换代码）是基于拉丁字母的一套电脑编码系统ASCII码中只包含英文字母，数字以及特殊字符与二进制的对应关系，主要用于显示现代英语和其他西欧语言，其最多只能用 8 位来表示（一个字节），即：2**8 = 256，所以，ASCII码最多只能表示 256 个符号。\nASCII码：包含英文字母，数字，特殊字符与01010101对应关系。\nASCII码产生原因以及时间\n下面是具体的ASCII码：\n   Bin(二进制) Oct(八进制) Dec(十进制) Hex(十六进制) 缩写/字符 解释     0000 0000 0 0 00 NUL(null) 空字符   0000 0001 1 1 01 SOH(start of headline) 标题开始   0000 0010 2 2 02 STX (start of text) 正文开始   0000 0011 3 3 03 ETX (end of text) 正文结束   0000 0100 4 4 04 EOT (end of transmission) 传输结束   0000 0101 5 5 05 ENQ (enquiry) 请求   0000 0110 6 6 06 ACK (acknowledge) 收到通知   0000 0111 7 7 07 BEL (bell) 响铃   0000 1000 10 8 08 BS (backspace) 退格   0000 1001 11 9 09 HT (horizontal tab) 水平制表符   0000 1010 12 10 0A LF (NL line feed, new line) 换行键   0000 1011 13 11 0B VT (vertical tab) 垂直制表符   0000 1100 14 12 0C FF (NP form feed, new page) 换页键   0000 1101 15 13 0D CR (carriage return) 回车键   0000 1110 16 14 0E SO (shift out) 不用切换   0000 1111 17 15 0F SI (shift in) 启用切换   0001 0000 20 16 10 DLE (data link escape) 数据链路转义   0001 0001 21 17 11 DC1 (device control 1) 设备控制1   0001 0010 22 18 12 DC2 (device control 2) 设备控制2   0001 0011 23 19 13 DC3 (device control 3) 设备控制3   0001 0100 24 20 14 DC4 (device control 4) 设备控制4   0001 0101 25 21 15 NAK (negative acknowledge) 拒绝接收   0001 0110 26 22 16 SYN (synchronous idle) 同步空闲   0001 0111 27 23 17 ETB (end of trans. block) 结束传输块   0001 1000 30 24 18 CAN (cancel) 取消   0001 1001 31 25 19 EM (end of medium) 媒介结束   0001 1010 32 26 1A SUB (substitute) 代替   0001 1011 33 27 1B ESC (escape) 换码(溢出)   0001 1100 34 28 1C FS (file separator) 文件分隔符   0001 1101 35 29 1D GS (group separator) 分组符   0001 1110 36 30 1E RS (record separator) 记录分隔符   0001 1111 37 31 1F US (unit separator) 单元分隔符   0010 0000 40 32 20 (space) 空格   0010 0001 41 33 21 ! 叹号   0010 0010 42 34 22 \u0026quot; 双引号   0010 0011 43 35 23 # 井号   0010 0100 44 36 24 $ 美元符   0010 0101 45 37 25 % 百分号   0010 0110 46 38 26 \u0026amp; 和号   0010 0111 47 39 27 ' 闭单引号   0010 1000 50 40 28 ( 开括号   0010 1001 51 41 29 ) 闭括号   0010 1010 52 42 2A * 星号   0010 1011 53 43 2B + 加号   0010 1100 54 44 2C , 逗号   0010 1101 55 45 2D - 减号/破折号   0010 1110 56 46 2E . 句号   00101111 57 47 2F / 斜杠   00110000 60 48 30 0 数字0   00110001 61 49 31 1 数字1   00110010 62 50 32 2 数字2   00110011 63 51 33 3 数字3   00110100 64 52 34 4 数字4   00110101 65 53 35 5 数字5   00110110 66 54 36 6 数字6   00110111 67 55 37 7 数字7   00111000 70 56 38 8 数字8   00111001 71 57 39 9 数字9   00111010 72 58 3A : 冒号   00111011 73 59 3B ; 分号   00111100 74 60 3C \u0026lt; 小于   00111101 75 61 3D = 等号   00111110 76 62 3E \u0026gt; 大于   00111111 77 63 3F ? 问号   01000000 100 64 40 @ 电子邮件符号   01000001 101 65 41 A 大写字母A   01000010 102 66 42 B 大写字母B   01000011 103 67 43 C 大写字母C   01000100 104 68 44 D 大写字母D   01000101 105 69 45 E 大写字母E   01000110 106 70 46 F 大写字母F   01000111 107 71 47 G 大写字母G   01001000 110 72 48 H 大写字母H   01001001 111 73 49 I 大写字母I   01001010 112 74 4A J 大写字母J   01001011 113 75 4B K 大写字母K   01001100 114 76 4C L 大写字母L   01001101 115 77 4D M 大写字母M   01001110 116 78 4E N 大写字母N   01001111 117 79 4F O 大写字母O   01010000 120 80 50 P 大写字母P   01010001 121 81 51 Q 大写字母Q   01010010 122 82 52 R 大写字母R   01010011 123 83 53 S 大写字母S   01010100 124 84 54 T 大写字母T   01010101 125 85 55 U 大写字母U   01010110 126 86 56 V 大写字母V   01010111 127 87 57 W 大写字母W   01011000 130 88 58 X 大写字母X   01011001 131 89 59 Y 大写字母Y   01011010 132 90 5A Z 大写字母Z   01011011 133 91 5B [ 开方括号   01011100 134 92 5C \\ 反斜杠   01011101 135 93 5D ] 闭方括号   01011110 136 94 5E ^ 脱字符   01011111 137 95 5F _ 下划线   01100000 140 96 60 ` | 开单引号 |    01100001 141 97 61 a 小写字母a   01100010 142 98 62 b 小写字母b   01100011 143 99 63 c 小写字母c   01100100 144 100 64 d 小写字母d   01100101 145 101 65 e 小写字母e   01100110 146 102 66 f 小写字母f   01100111 147 103 67 g 小写字母g   01101000 150 104 68 h 小写字母h   01101001 151 105 69 i 小写字母i   01101010 152 106 6A j 小写字母j   01101011 153 107 6B k 小写字母k   01101100 154 108 6C l 小写字母l   01101101 155 109 6D m 小写字母m   01101110 156 110 6E n 小写字母n   01101111 157 111 6F o 小写字母o   01110000 160 112 70 p 小写字母p   01110001 161 113 71 q 小写字母q   01110010 162 114 72 r 小写字母r   01110011 163 115 73 s 小写字母s   01110100 164 116 74 t 小写字母t   01110101 165 117 75 u 小写字母u   01110110 166 118 76 v 小写字母v   01110111 167 119 77 w 小写字母w   01111000 170 120 78 x 小写字母x   01111001 171 121 79 y 小写字母y   01111010 172 122 7A z 小写字母z   01111011 173 123 7B { 开花括号   01111100 174 124 7C | 垂线   01111101 175 125 7D } 闭花括号   01111110 176 126 7E ~ 波浪号   01111111 177 127 7F DEL (delete)     GBK：只包含本国文字（以及英文字母，数字，特殊字符）与0101010对应关系。\nUnicode： 包含全世界所有的文字与二进制0101001的对应关系。\nUTF-8:*包含全世界所有的文字与二进制0101001的对应关系（最少用8位一个字节表示一个字符）。*\nUTF-8（8-bit Unicode Transformation Format）是一种针对Unicode的可变长度字符编码，又称万国码，由Ken Thompson于1992年创建。现在已经标准化为RFC 3629。UTF-8用1到6个字节编码Unicode字符。用在网页上可以统一页面显示中文简体繁体及其它语言（如英文，日文，韩文）。\rUTF-8 ：最少用8位数,去表示一个字符.\n　英文: 8位,1个字节表示.\n　欧洲文字: 16位,两个字节表示一个字符.\n　中文,亚洲文字: 24位,三个字节表示.\n","description":"","id":26,"section":"posts","tags":null,"title":"","uri":"https://ymmeng.github.io/zh/posts/python/python%E5%9F%BA%E7%A1%80-%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%87%BAwhile%E5%BE%AA%E7%8E%AF%E7%BC%96%E7%A0%81/"},{"content":"模块 what is 模块：本质就是.py文件，它是封装语句的最小单位。\n自定义模块：实际上就是定义一个.py文件。其中可以包括：变量定义，可执行语句，for循环，函数定义等等，他们统称模块的成员。\n模块运行的方式：  脚本方式：直接用解释器执行，或者PyCharm中用邮件运行。 模块方式：被其他的模块导入。为导入他的模块提供资源(函数定义，类定义，变量等)。  __name__属性的使用： 在脚本方式运行时，__name__是固定字符串：__main__\n再以模块方式被导入时，__name__本就是模块的名字。\n系统导入模块路径  内存中：如果之前成功导入过某个模块，直接使用以及存在的模块 内置路径下：安装路径下：Lib PYTHONPATH：import时寻找模块的路径。 sys.path：是一个路径列表。  如果上面都找不到，就会报错。\n__file__获取当前文件绝对路径\nos.path.dirname(__file__) #获取当前父路径\n导入模块的多种方式：  import ***：导入一个模块的所有成员 import a,b,c：一次性导入多个模块的成员，不推荐这种写法 from a import b：从a模块中导入b  相对路径：包含了点号的一个相对路径。\n.表示的是当前的路径；\n..表示的是父路径；\n\u0026hellip;表示的是父路径的父路径。\n例：\n from ..z import zz from ..z.zz import *\n ","description":"","id":27,"section":"posts","tags":null,"title":"","uri":"https://ymmeng.github.io/zh/posts/python/%E6%A8%A1%E5%9D%97/"},{"content":"标准版的装饰器: 装饰器的本质就是闭包 1 2 3 4 5 6 7  def wrapper(f):\rdef inner(*args,**kwargs):\r\u0026#39;\u0026#39;\u0026#39;添加额外的功能：执行被装饰函数之前的操作\u0026#39;\u0026#39;\u0026#39;\rret = f(*args,**kwargs)\r\u0026#39;\u0026#39;\u0026#39;添加额外的功能：执行被装饰函数之后的操作\u0026#39;\u0026#39;\u0026#39;\rreturn ret\rreturn inner\r  装饰器的应用：登录认证 ","description":"","id":28,"section":"posts","tags":null,"title":"","uri":"https://ymmeng.github.io/zh/posts/python/%E8%A3%85%E9%A5%B0%E5%99%A8/"},{"content":"迭代器 1) 可迭代对象定义\n在python中，但凡内部含有__iter__方法的对象，都是可迭代对象。\n　2) 查看对象内部方法\n该对象内部含有什么方法除了看源码还有什么其他的解决方式么？当然有了， 可以通过dir() 去判断一个对象具有什么方法\n1 2  s1 = \u0026#39;alex\u0026#39;\rprint(dir(s1))\r  dir()会返回一个列表，这个列表中含有该对象的以字符串的形式所有方法名。这样我们就可以判断python中的一个对象是不是可迭代对象了：\n1 2 3 4  s1 = \u0026#39;alex\u0026#39;\ri = 100\rprint(\u0026#39;__iter__\u0026#39; in dir(i)) # False\r print(\u0026#39;__iter__\u0026#39; in dir(s1)) # True\r   　3)小结：\n从字面意思来说：可迭代对象就是一个可以重复取值的实实在在的东西。\n从专业角度来说：但凡内部含有__iter__方法的对象，都是可迭代对象。\n可迭代对象可以通过判断该对象是否有’iter’方法来判断。\n可迭代对象的优点：\n​ 可以直观的查看里面的数据。\n可迭代对象的缺点：\n​ \\1. 占用内存。\n​ \\2. 可迭代对象不能迭代取值（除去索引，key以外）。\n那么这个缺点有人就提出质疑了，即使抛去索引,key以外，这些我可以通过for循环进行取值呀！对，他们都可以通过for循环进行取值，其实for循环在底层做了一个小小的转化，就是先将可迭代对象转化成迭代器，然后在进行取值的。那么接下来，我们就看看迭代器是个什么鬼。\n","description":"","id":29,"section":"posts","tags":null,"title":"","uri":"https://ymmeng.github.io/zh/posts/python/%E8%BF%AD%E4%BB%A3%E5%99%A8/"},{"content":"面向对象 面向对象基础 ​\t在用面向对象的时候一般类名用大写字母开头，函数名用小写字母开头\n类 1 2 3  def FunctionName(args):\r\u0026#39;函数文档字符串\u0026#39;\r函数体\r  实例化 1 2 3 4 5 6 7 8 9 10  class Person: #定义一个人类\r role = \u0026#39;person\u0026#39; #人的角色属性都是人\r def __init__(self,name):\rself.name = name # 每一个角色都有自己的昵称;\r def walk(self): #人都可以走路，也就是有一个走路方法\r print(\u0026#34;person is walking...\u0026#34;)\rprint(Person.role) #查看人的role属性\r print(Person.walk) #引用人的走路方法，注意，这里不是在调用\r   语法：对象名 = 类型(参数)\n查看属性\u0026amp;调用方法\n1 2  print(对象名.属性名) #查看属性\r print(对象名.方法名) #调用方法\r   类的补充 1 2 3 4 5 6 7 8 9 10 11 12  一：我们定义的类的属性到底存到哪里了？有两种方式查看\rdir(类名)：查出的是一个名字列表\r类名.__dict__:查出的是一个字典，key为属性名，value为属性值\r二：特殊的类属性\r类名.__name__# 类的名字(字符串)\r 类名.__doc__# 类的文档字符串\r 类名.__base__# 类的第一个父类(在讲继承时会讲)\r 类名.__bases__# 类所有父类构成的元组(在讲继承时会讲)\r 类名.__dict__# 类的字典属性\r 类名.__module__# 类定义所在的模块\r 类名.__class__# 实例对应的类(仅新式类中)\r   小节 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class 类名：\r def __init__(self,参数1，参数2)：\rself.对象的属性1 = 参数1\rself.对象的属性2 = 参数2\rdef 方法名(self):pass\rdef 方法名2(self):pass\r对象名 = 类名(1,2) #对象就是实例，代表一个具体的东西\r #类名() : 类名+括号就是实例化一个类，相当于调用了__init__方法\r #括号里传参数，参数不需要传self，其他与init中的形参一一对应\r #结果返回一个对象\r 对象名.对象的属性1 #查看对象的属性，直接用 对象名.属性名 即可\r 对象名.方法名() #调用类中的方法，直接用 对象名.方法名() 即可\r   对象之间的交互 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Person:\rrole = \u0026#39;person\u0026#39;\rdef __init(self,name,aggressivity,life_value):\rself.name = name\rself.aggressivity = aggressivity\rself.life_value = life_value\rdef attack(self,dog):\rdog.life_value -= self.aggressivity\rclass Dog:\rrole = \u0026#39;dog\u0026#39;\rdef __init(self,name,breed,aggressivity,life_value):\rself.name = name\rself.breed = breed\rself.aggressivity = aggressivity\rself.life_value = life_value\rdef bite(self,people)\rpeople.life_value -= self.aggressivity\regg = Person(\u0026#39;agon\u0026#39;,10,1000)\rha2 = Dog(\u0026#39;erlengzi\u0026#39;,\u0026#39;哈士奇\u0026#39;，10,1000)\rprint(ha2.life.value)\regg.attack(ha2)\rprint(ha2.life.value)\r  再来一个例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  from math import pi\rclass Circle:\r\u0026#39;\u0026#39;\u0026#39;\r定义了一个圆形类；\r提供计算面积(area)和周长(perimeter)的方法\r\u0026#39;\u0026#39;\u0026#39;\rdef __init__(self,radius):\rself.radius = radius\rdef area(self):\rreturn pi * self.radius * self.radius\rdef perimeter(self):\rreturn 2 * pi *self.radius\rcircle = Circle(10) #实例化一个圆\r area1 = circle.area() #计算圆面积\r per1 = circle.perimeter() #计算圆周长\r print(area1,per1) #打印圆面积和周长\r   面向对象的三大特征 继承 what is 继承：儿子有了父亲，父亲有了爷爷，反过来就是继承\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  #继承的代码实现\r class Animal:\rdef eat(self):\rprint(\u0026#34;%s吃 \u0026#34; %self.name)\rdef drink(self):\rprint (\u0026#34;%s喝 \u0026#34; %self.name)\rclass Cat(Animal):\rdef __init__(self, name):\rself.name = name\rself.breed = \u0026#39;猫\u0026#39;\rdef climb(self):\rprint(\u0026#39;爬树\u0026#39;)\rclass Dog(Animal):\rdef __init__(self, name):\rself.name = name\rself.breed=\u0026#39;狗\u0026#39;\rdef look_after_house(self):\rprint(\u0026#39;汪汪叫\u0026#39;)\r# ######### 执行 #########\r c1 = Cat(\u0026#39;小白家的小黑猫\u0026#39;)\rc1.eat()\rc2 = Cat(\u0026#39;小黑的小白猫\u0026#39;)\rc2.drink()\rd1 = Dog(\u0026#39;胖子家的小瘦狗\u0026#39;)\rd1.eat()\r  ​\t提示：用已经有的类建立一个新的类，这样就重用了已经有的软件中的一部分设置大部分，大大生了编程工作量，这就是常说的软件重用，不仅可以重用自己的类，也可以继承别人的，比如标准库，来定制新的数据类型，这样就是大大缩短了软件开发周期，对大型软件开发来说，意义重大.\n派生 ​\t当然子类也可以添加自己新的属性或者在自己这里重新定义这些属性（不会影响到父类），需要注意的是，一旦重新定义了自己的属性且与父类重名，那么调用新增的属性时，就以自己为准了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39  class Animal:\r\u0026#39;\u0026#39;\u0026#39;\r人和狗都是动物，所以创造一个Animal基类\r\u0026#39;\u0026#39;\u0026#39;\rdef __init__(self, name, aggressivity, life_value):\rself.name = name # 人和狗都有自己的昵称;\r self.aggressivity = aggressivity # 人和狗都有自己的攻击力;\r self.life_value = life_value # 人和狗都有自己的生命值;\r def eat(self):\rprint(\u0026#39;%sis eating\u0026#39;%self.name)\rclass Dog(Animal):\r\u0026#39;\u0026#39;\u0026#39;\r狗类，继承Animal类\r\u0026#39;\u0026#39;\u0026#39;\rdef bite(self, people):\r\u0026#39;\u0026#39;\u0026#39;\r派生：狗有咬人的技能\r:param people: \u0026#39;\u0026#39;\u0026#39;\rpeople.life_value -= self.aggressivity\rclass Person(Animal):\r\u0026#39;\u0026#39;\u0026#39;\r人类，继承Animal\r\u0026#39;\u0026#39;\u0026#39;\rdef attack(self, dog):\r\u0026#39;\u0026#39;\u0026#39;\r派生：人有攻击的技能\r:param dog: \u0026#39;\u0026#39;\u0026#39;\rdog.life_value -= self.aggressivity\regg = Person(\u0026#39;egon\u0026#39;,10,1000)\rha2 = Dog(\u0026#39;二愣子\u0026#39;,50,1000)\rprint(ha2.life_value)\rprint(egg.attack(ha2))\rprint(ha2.life_value)\r  super 在python3中，子类执行父类的方法也可以直接用super方法.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  class A:\rdef hahaha(self):\rprint(\u0026#39;A\u0026#39;)\rclass B(A):\rdef hahaha(self):\rsuper().hahaha()\r#super(B,self).hahaha()\r #A.hahaha(self)\r print(\u0026#39;B\u0026#39;)\ra = A()\rb = B()\rb.hahaha()\rsuper(B,b).hahaha()\r  接口类 继承有两种用途：\n一：继承基类的方法，并且做出自己的改变或者扩展（代码重用）\n二：声明某个子类兼容于某基类，定义一个接口类Interface，接口类中定义了一些接口名（就是函数名）且并未实现接口的功能，子类继承接口类，并且实现接口中的功能\n借用abc模块来实现接口\n1 2 3 4 5 6 7 8 9 10 11 12 13  from abc import ABCMeta,abstractmethod\rclass Payment(metaclass=ABCMeta):\r@abstractmethod\rdef pay(self,money):\rpass\rclass Wechatpay(Payment):\rdef fuqian(self,money):\rprint(\u0026#39;微信支付了%s元\u0026#39;%money)\rp = Wechatpay() #不调就报错了\r   抽象类  抽象类的本质还是类，指的是一组类的相似性，包括数据属性（如all_type）和函数属性（如read、write），而接口只强调函数属性的相似性。 抽象类是一个介于类和接口直接的一个概念，同时具备类和接口的部分特性，可以用来实现归一化设计 在python中，并没有接口类这种东西，即便不通过专门的模块定义接口，我们也应该有一些基本的概念。  钻石继承 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  class A(object):\rdef test(self):\rprint(\u0026#39;from A\u0026#39;)\rclass B(A):\rdef test(self):\rprint(\u0026#39;from B\u0026#39;)\rclass C(A):\rdef test(self):\rprint(\u0026#39;from C\u0026#39;)\rclass D(B):\rdef test(self):\rprint(\u0026#39;from D\u0026#39;)\rclass E(C):\rdef test(self):\rprint(\u0026#39;from E\u0026#39;)\rclass F(D,E):\r# def test(self):\r # print(\u0026#39;from F\u0026#39;)\r pass\rf1=F()\rf1.test()\rprint(F.__mro__) #只有新式才有这个属性可以查看线性列表，经典类没有这个属性\r #新式类继承顺序:F-\u0026gt;D-\u0026gt;B-\u0026gt;E-\u0026gt;C-\u0026gt;A\r #经典类继承顺序:F-\u0026gt;D-\u0026gt;B-\u0026gt;A-\u0026gt;E-\u0026gt;C\r #python3中统一都是新式类\r #pyhon2中才分新式类与经典类\r   查看继承顺序用、：对象名.mro 来查看\n继承小结   继承的作用\n  减少代码的重用\n  提高代码可读性\n  规范编程模式\n  几个名词\n  1 2 3  抽象：抽象即抽取类似或者说比较像的部分。是一个从具题到抽象的过程。\r继承：子类继承了父类的方法和属性\r派生：子类在父类方法和属性的基础上产生了新的方法和属性\r      抽象类与接口类\n  1.多继承问题\r在继承抽象类的过程中，我们应该尽量避免多继承；\r而在继承接口的时候，我们反而鼓励你来多继承接口\r  2.方法的实现\r在抽象类中，我们可以对一些抽象方法做出基础实现；\r而在接口类中，任何方法都只是一种规范，具体的功能需要子类实现\r  封装  作用  1、将变化隔离； 2、便于使用； 3、提高复用性 4、提高安全性 封装原则  将不需要对外提供的内容都隐藏起来； 把属性都隐藏，提供公共方法对其访问。      私有变量 1 2 3 4 5 6 7 8 9 10 11 12 13  #其实这仅仅这是一种变形操作\r #类中所有双下划线开头的名称如__x都会自动变形成：_类名__x的形式：\r class A:\r__N=0 #类的数据属性就应该是共享的,但是语法上是可以把类的数据属性设置成私有的如__N,会变形为_A__N\r def __init__(self):\rself.__X=10 #变形为self._A__X\r def __foo(self): #变形为_A__foo\r print(\u0026#39;from A\u0026#39;)\rdef bar(self):\rself.__foo() #只有在类内部才可以通过__foo的形式访问到.\r #A._A__N是可以访问到的，即这种操作并不是严格意义上的限制外部访问，仅仅只是一种语法意义上的变形\r   这种自动变形的特点：\n1.类中定义的x只能在内部使用，如self.x，***引用的就是变形的结果***。\n*2.这种变形其实正是针对外部的变形**，在外部是无法通过__x这个名字访问到的。*\n3.在子类定义的__x不会覆盖在*父类定义的__x，因为子类中变形成了：_子类名__x,而父类中变形成了：_父类名__x，即双下滑线开头的属性在继承给子类时，子类是无法覆盖的。*\n私有方法 在继承中，父类如果不想让子类覆盖自己的方法，可以将方法定义为私有的\n#正常情况\r\u0026gt;\u0026gt;\u0026gt; class A:\r... def fa(self):\r... print('from A')\r... def test(self):\r... self.fa()\r... \u0026gt;\u0026gt;\u0026gt; class B(A):\r... def fa(self):\r... print('from B')\r... \u0026gt;\u0026gt;\u0026gt; b=B()\r\u0026gt;\u0026gt;\u0026gt; b.test()\rfrom B\r#把fa定义成私有的，即__fa\r\u0026gt;\u0026gt;\u0026gt; class A:\r... def __fa(self): #在定义时就变形为_A__fa\r... print('from A')\r... def test(self):\r... self.__fa() #只会与自己所在的类为准,即调用_A__fa\r... \u0026gt;\u0026gt;\u0026gt; class B(A):\r... def __fa(self):\r... print('from B')\r... \u0026gt;\u0026gt;\u0026gt; b=B()\r\u0026gt;\u0026gt;\u0026gt; b.test()\rfrom A\rproperty属性 什么是特性property\nproperty是一种特殊的属性，访问它时会执行一段功能（函数）然后返回值(就是加不加括号的区别，，，，)\n你胖吗？\n过轻：低于18.5\r正常：18.5-23.9\r过重：24-27\r肥胖：28-32\r非常肥胖, 高于32\r1 2 3 4 5 6 7 8 9 10 11  class People:\rdef __init__(self,name,weight,height):\rself.name=name\rself.weight=weight\rself.height=height\r@property\rdef bmi(self):\rreturn self.weight / (self.height**2)\rp1=People(\u0026#39;egon\u0026#39;,75,1.85)\rprint(p1.bmi)\r  为什么要用property\n将一个类的函数定义成特性以后，对象再去使用的时候obj.name,根本无法察觉自己的name是执行了一个函数然后计算出来的，这种特性的使用方式遵循了统一访问的原则\n除此之外，看下\n1 2 3 4 5 6 7  ps：面向对象的封装有三种方式:\r【public】\r这种其实就是不封装,是对外公开的\r【protected】\r这种封装方式对外不公开,但对朋友(friend)或者子类(形象的说法是“儿子”,但我不知道为什么大家 不说“女儿”,就像“parent”本来是“父母”的意思,但中文都是叫“父类”)公开\r【private】\r这种封装对谁都不公开\r  一个静态属性property本质就是实现了get，set，delete三种方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Foo:\r@property\rdef AAA(self):\rprint(\u0026#39;get的时候运行我啊\u0026#39;)\r@AAA.setter\rdef AAA(self,value):\rprint(\u0026#39;set的时候运行我啊\u0026#39;)\r@AAA.deleter\rdef AAA(self):\rprint(\u0026#39;delete的时候运行我啊\u0026#39;)\r#只有在属性AAA定义property后才能定义AAA.setter,AAA.deleter\r f1=Foo()\rf1.AAA\rf1.AAA=\u0026#39;aaa\u0026#39;\rdel f1.AAA\r  classmethod 1 2 3 4 5 6 7  class Classmethod_Demo():\rrole = \u0026#39;dog\u0026#39;\r@classmethod\rdef func(cls):\rprint(cls.role)\rClassmethod_Demo.func()\r  staticmethod 1 2 3 4 5 6 7  class Staticmethod_Demo():\rrole = \u0026#39;dog\u0026#39;\r@staticmethod\rdef func():\rprint(\u0026#34;当普通方法用\u0026#34;)\rStaticmethod_Demo.func()\r  多态   多态指的是一类事物有多种形态\n​\t动物有多种形态：人，狗，猪\n  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  import abc\rclass Animal(metaclass=abc.ABCMeta): #同一类事物:动物\r @abc.abstractmethod\rdef talk(self):\rpass\rclass People(Animal): #动物的形态之一:人\r def talk(self):\rprint(\u0026#39;say hello\u0026#39;)\rclass Dog(Animal): #动物的形态之二:狗\r def talk(self):\rprint(\u0026#39;say wangwang\u0026#39;)\rclass Pig(Animal): #动物的形态之三:猪\r def talk(self):\rprint(\u0026#39;say aoao\u0026#39;)\r  多态性 1 2 3 4 5  在面向对象方法中一般是这样表述多态性：\r向不同的对象发送同一条消息（！！！obj.func():是调用了obj的方法func，又称为向obj发送了一条消息func），不同的对象在接收时会产生不同的行为（即方法）。\r也就是说，每个对象可以用自己的方式去响应共同的消息。所谓消息，就是调用函数，不同的行为就是指不同的实现，即执行不同的函数。\r比如：老师.下课铃响了（），学生.下课铃响了()，老师执行的是下班操作，学生执行的是放学操作，虽然二者消息一样，但是执行的效果不同\r  1 2 3 4 5 6 7 8 9 10 11 12 13 14  peo=People()\rdog=Dog()\rpig=Pig()\r#peo、dog、pig都是动物,只要是动物肯定有talk方法\r #于是我们可以不用考虑它们三者的具体是什么类型,而直接使用\r peo.talk()\rdog.talk()\rpig.talk()\r#更进一步,我们可以定义一个统一的接口来使用\r def func(obj):\robj.talk()\r  鸭子类型 逗比时刻：\n　Python崇尚鸭子类型，即‘如果看起来像、叫声像而且走起路来像鸭子，那么它就是鸭子’\npython程序员通常根据这种行为来编写程序。例如，如果想编写现有对象的自定义版本，可以继承该对象\n也可以创建一个外观和行为像，但与它无任何关系的全新对象，后者通常用于保存程序组件的松耦合度。\n例1：利用标准库中定义的各种‘与文件类似’的对象，尽管这些对象的工作方式像文件，但他们没有继承内置文件对象的方法\n例2：序列类型有多种形态：字符串，列表，元组，但他们直接没有直接的继承关系\n1 2 3 4 5 6 7 8 9 10 11 12 13  #二者都像鸭子,二者看起来都像文件,因而就可以当文件一样去用\r class TxtFile:\rdef read(self):\rpass\rdef write(self):\rpass\rclass DiskFile:\rdef read(self):\rpass\rdef write(self):\rpass\r  面向对象进阶 isinstance和issubclass isinstance(obj,cls)检查是否obj是否是类 cls 的对象\n1 2 3 4 5 6  class Foo(object):\rpass\robj = Foo()\risinstance(obj, Foo)\r  issubclass(sub, super)检查sub类是否是 super 类的派生类\nclass Foo(object):\rpass\rclass Bar(Foo):\rpass\rissubclass(Bar, Foo)\r反射 what is 反射？？？ 主要是指程序可以访问、检测和修改它本身状态或行为的一种能力（自省）。\npython面向对象中的反射：通过字符串的形式操作对象相关的属性。python中的一切事物都是对象（都可以使用反射）\n四个可以实现自省的函数\n下列方法适用于类和对象（一切皆对象，类本身也是一个对象）\n1  callable()判断变量是否可以调用\r  hasattr(对象名,方法名)判断对象是不是一个可执行的方法(函数)\ngetattr(对象名,方法名)执行方法\nstr__和__repr 改变对象的字符串显示__str__,__repr__\nitem系列 getitem_setitem___delitem__ __del__ 析构方法，当对象在内存中被释放时，自动触发执行。\n注：此方法一般无须定义，因为Python是一门高级语言，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给Python解释器来执行，所以，析构函数的调用是由解释器在进行垃圾回收时自动触发执行的。\n例：\n1 2 3 4 5 6 7 8 9 10 11 12  class Foo:\rdef __del__(self):\rprint(\u0026#39;执行我啦\u0026#39;)\rf1=Foo()\rdel f1\rprint(\u0026#39;-------\u0026gt;\u0026#39;)\r#输出结果\r 执行我啦\r-------\u0026gt;\r  __new__ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Person(object):\rdef __new__(cls, name, age):\rprint \u0026#39;__new__ called.\u0026#39;\rreturn super(Person, cls).__new__(cls, name, age)\rdef __init__(self, name, age):\rprint \u0026#39;__init__ called.\u0026#39;\rself.name = name\rself.age = age\rdef __str__(self):\rreturn \u0026#39;\u0026lt;Person: %s(%s)\u0026gt;\u0026#39; % (self.name, self.age)\rif __name__ == \u0026#39;__main__\u0026#39;:\rname = Person(\u0026#39;xxx\u0026#39;, 24)\rprint name\r  当实例化的时候，结果:\n1 2 3  __new__ called.\r__init__ called.\r\u0026lt;Person: xxx(24)\u0026gt;\r  __call__ 对象后面加括号，触发执行。\n注：构造方法的执行是由创建对象触发的，即：对象 = 类名() ；而对于 call 方法的执行是由对象后加括号触发的，即：对象() 或者 类()()\n1 2 3 4 5 6 7 8 9 10 11 12  class Foo:\rdef __init__(self):\rpass\rdef __call__(self, *args, **kwargs):\rprint(\u0026#39;__call__\u0026#39;)\robj = Foo() # 执行 __init__\r obj() # 执行 __call__\r   with和__enter__,__exit__ __len__ 1 2 3 4 5 6 7 8 9  class A:\rdef __init__(self):\rself.a = 1\rself.b = 2\rdef __len__(self):\rreturn len(self.__dict__)\ra = A()\rprint(len(a))\r  __hash__ 1 2 3 4 5 6 7 8 9  class A:\rdef __init__(self):\rself.a = 1\rself.b = 2\rdef __hash__(self):\rreturn hash(str(self.a)+str(self.b))\ra = A()\rprint(hash(a))\r  __eq__ 面试题\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  class Person:\rdef __init__(self,name,age,sex):\rself.name = name\rself.age = age\rself.sex = sex\rdef __hash__(self):\rreturn hash(self.name+self.sex)\rdef __eq__(self, other):\rif self.name == other.name and self.sex == other.sex:return True\rp_lst = []\rfor i in range(84):\rp_lst.append(Person(\u0026#39;egon\u0026#39;,i,\u0026#39;male\u0026#39;))\rprint(p_lst)\rprint(set(p_lst))\r  ","description":"","id":30,"section":"posts","tags":null,"title":"","uri":"https://ymmeng.github.io/zh/posts/python/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"content":"css常用样式 上下左右置中对齐 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  #id {\rposition: absolute;\rtop:50%;\rleft:50%;\rtransform: translateX(-50%) translateY(-50%);\r}\rbody {\rmin-height: 100vh;\rdisplay: flex;\rjustify-content: center;\ralign-items: center;\r}\rtext-align: justify; /*文字对其*/\r  闭合浮动 1 2 3 4 5 6 7 8 9 10 11  .class{\roverflow:hidden;\r}\r.class{\rdisplay:flow-root;\r}\r.class::after{\rcontent:\u0026#39;\u0026#39;;\rclear:both;\rdisplay:block;\r}\r  ","description":"","id":31,"section":"posts","tags":null,"title":"","uri":"https://ymmeng.github.io/zh/posts/%E5%89%8D%E7%AB%AF/css/"},{"content":"JavaScript学习笔记 1 2 3 4 5 6 7 8  alert(\u0026#34;出来一个弹框\u0026#34;)\rdocument.write(\u0026#34;向body标签内写入东西\u0026#34;)\rconsole.log(\u0026#34;向控制台输出内容\u0026#34;)\rconsole.log(typeof a) #检查a的类型\rNumber.MAX_VALUE #表示最大值\rInfinity\t#表示正无穷\rNaN\t#表示非数字\r  类型的转换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  a = String(a)\t#将a转换成字符串类型\ra = Number(a)\t#将a转换成数值类型\ra = parseInt(a,10)\t#将字符串中的整数转换成数值，只要碰到非数值就停止,以十进制方式输出\ra = parseFint(a)\t#将字符串中的小数转换成数值，只要碰到非数值就停止\ra = Boolean(a)\t#将变量类型转换为布尔类型\ra++\t#自增前的值\r++a\t#自增后的值\r三元运算符\r语法：\r条件表达式?语句1:语句2;\r如果该值为true，执行语句1\r如果该值为false，执行语句2\rprompt()\t#输入函数\r  编码\n在js中用\\u加十六进制\n在h5中用\u0026amp;#加十进制\n循环 1 2 3 4 5 6 7 8 9 10 11 12  while循环\rwhile(条件){\r执行语句\r}\rdo{\r执行语句 }while(条件)\t#前执行再判断\rfor循环\rfor(条件){\r执行语句\r}\r  获取元素 1 2 3 4 5 6 7  document.getElementById(\u0026#39;通过ID获取元素\u0026#39;)\rdocument.getElementsByTagName(\u0026#39;通过标签获取元素\u0026#39;)\rwindow.onload #防止没有加载完东西\r事件onmouseover\r​onmouseout\r​onclick\r  内置函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  arguments #存了数组内所有的内容，可以循环取出来\rstyle #获取行间元素\rcurrentStyle\t#获取非行间元素\rgetStyle\t#获取样式\rtoLowerCase\t#转换成小写\r#数组的定义\rvar arr = [1,2,3] == var arr = new Array(1,2,3)\r#数组的方法\rarr = [1,2,3,4,5,6]\rarr.push()\t#从尾部添加\rarr.unshift()\t#从头部添加\rarr.pop()\t#从尾部删除\rarr.shift()\t#从头部删除\rarr.splice(1,2)\t#从第2个下标开始删除，删除2个元素\rarr.splice(1,0，\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;)\t#从第2个下表开始插入，插入\u0026#39;a\u0026#39;和\u0026#39;b\u0026#39;\rarr.splice(1,2，\u0026#39;a\u0026#39;,\u0026#39;b\u0026#39;)\t#从第2个下表开始替换，替换成\u0026#39;a \u0026#39;和\u0026#39;b\u0026#39;\rarr.concat(数组)\t#连接两个数组\rarr.sort()\t#排序这个数组-字符串\rarr.sort(function(n1-n2){n1-n2})\t#排序这个数组-数值\rarr.join(\u0026#39;-\u0026#39;)\t#拼接数组之间的内容，用\u0026#39;-\u0026#39;\r#兼容性示例：\rif(obj.currentSytle){\rreturn obj.currentStyle[name];\r}else{\rreturn getComputedStyle(obj,false)[name];\r}\r  定时器 1 2 3 4 5 6 7 8  function show(){\ralert(\u0026#39;a\u0026#39;)\r}\rsetInterval(show,1000)\t#每隔1秒钟执行一次，重复执行\rsetTimeout(show,1000)\t#隔1秒钟执行一次，执行一次\rclearInterval()\t#关闭定时器\rclearTimeout()\t#关闭定时器\r  Dom 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  #子节点\rstr.childrn\rstr.childNodes\rfor (var i=0; i\u0026lt;str.childNodes.length;i++){\rif (str.childNodes[i].nodeType == 1){\rstr.childNodes[i].style.background = \u0026#39;red\u0026#39;;\r}\r}\r#父节点\rstr.parentNode\r#收尾节点\rfirstChild firstElementChild\rlastChild lastElementChild\r#兄弟节点\rnextSibling nextElementSibling\rpreviousSibling PreviousElementSibling\r#DOM方式操作元素属性\r获取：getAttribute(名称)\r设置：setAttribute(名称,值)\r删除：removeAttribute(名称)\r#例：获取当前列表下所有为 box 的 类 标签 并把 背景 设置为‘red’\rfunction getByClass(oParent,sClass){\rvar aResult=[];\rvar aEle=oParent.getElementsByTagName(\u0026#39;*\u0026#39;);\rfor(var i=0; i\u0026lt;aEle.length; i++){\rif(aEle[i].calssName==sClass){\raResult.push(aEle[i]);\r}\r}\rreturn aResult\r}\rwindow.onload = function(){\rvar oUl = document.getElementById(\u0026#39;ul\u0026#39;);\rvar aBox = getByClass(oUl,\u0026#39;box\u0026#39;);\rfor(var i=0;i\u0026lt;aBox;i++){\raBox[i].style.background = \u0026#39;red\u0026#39;;\r}\r}\r  Dom操作 1 2 3 4 5 6 7 8 9 10 11  父级.appendChild(子节点)\t#添加\r父级.insertBefore(子节点,原有节点[0])\t#插入\r父级.removeChild(当前.父级)\t#删除\rwindow.onload=function(){\rvar oBth = document.getElementById(\u0026#39;btn\u0026#39;);\rvar oUl = document.getElementById(\u0026#39;ul\u0026#39;);\roBth.onclick = function(){\rvar oLi = document.createElement(\u0026#39;li\u0026#39;);\roUl.appendChild(oLi);\r}\r}\r  数据类型 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  a 数组 (Array) b 布尔值 (Boolean) by 字节 (Byte) c 有符号字符 (Char) cb 无符号字符 (Char Byte，没有多少人用) cr 颜色参考值 (ColorRef) cx,cy 坐标差（长度 ShortInt） dw Double Word fn 函数 h Handle（句柄） i 整型 l 长整型 (Long Int) lp Long Pointer m_ 类的成员 n 短整型 (Short Int) np Near Pointer p Pointer s 字符串型 sz 以null做结尾的字符串型 (String with Zero End) w Word   Javascript事件 鼠标 oEvent=event||ev\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #冒泡取消\roEvent.cancelBubble=Ture; function getPos(ev)\r{\rvar scrollTop=document.documentElement.scrollTop||document.body.scrollTop;\rvar scrollLeft=document.documentElement.scrollLeft||document.body.scrollLeft;\rreturn {x: ev.clientX+scrollLeft, y: ev.clientY+scrollTop};\r}\rdocument.oncontextmenu = function() {\ralert(\u0026#39;想右键？？？门都没有\u0026#39;)\rreturn false;\r}\r  键盘 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  document.onkeydown = function(ev){\rvar oDiv = document.getElementById(\u0026#39;div1\u0026#39;);\rif(event.keyCode == 37){\roDiv.style.left=oDiv.offsetLeft-10+\u0026#39;px\u0026#39;;\r}else if (event.keyCode == 39){\roDiv.style.right=oDiv.offsetLeft-10+\u0026#39;px\u0026#39;;\r}else if (event.keyCode == 38){\roDiv.style.top=oDiv.offsettop-10+\u0026#39;px\u0026#39;;\r}else if (event.keyCode == 40){\roDiv.style.top=oDiv.offsettop+10+\u0026#39;px\u0026#39;;\r}\r}\rkeyCode\rctrlKey\rshiftKey\raltKey\r  ","description":"","id":32,"section":"posts","tags":null,"title":"","uri":"https://ymmeng.github.io/zh/posts/%E5%89%8D%E7%AB%AF/javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"content":"JS日期格式化转换方法 1. 将日期转换为指定的格式：比如转换成 年月日时分秒 这种格式：yyyy-MM-dd hh:mm:ss 或者 yyyy-MM-dd。\n可以为Date原型添加如下的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  Date.prototype.format = function(fmt) { var o = { \u0026#34;M+\u0026#34; : this.getMonth()+1, //月份  \u0026#34;d+\u0026#34; : this.getDate(), //日  \u0026#34;h+\u0026#34; : this.getHours(), //小时  \u0026#34;m+\u0026#34; : this.getMinutes(), //分  \u0026#34;s+\u0026#34; : this.getSeconds(), //秒  \u0026#34;q+\u0026#34; : Math.floor((this.getMonth()+3)/3), //季度  \u0026#34;S\u0026#34; : this.getMilliseconds() //毫秒  }; if(/(y+)/.test(fmt)) { fmt=fmt.replace(RegExp.$1, (this.getFullYear()+\u0026#34;\u0026#34;).substr(4 - RegExp.$1.length)); } for(var k in o) { if(new RegExp(\u0026#34;(\u0026#34;+ k +\u0026#34;)\u0026#34;).test(fmt)){ fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : ((\u0026#34;00\u0026#34;+ o[k]).substr((\u0026#34;\u0026#34;+ o[k]).length))); } } return fmt; }   比如我们可以这样调用下：\n1 2  var time1 = new Date().format(\u0026#34;yyyy-MM-dd hh:mm:ss\u0026#34;); console.log(time1);   运行如下：\n也可以转换成 ”年月日”的格式\n1 2  var time2 = new Date().format(\u0026#34;yyyy-MM-dd\u0026#34;); console.log(time2);   运行如下：\n2. 将指定的日期转换为\u0026quot;年月日\u0026quot;的格式，代码如下：\n1 2 3  var oldTime = (new Date(\u0026#34;2012/12/25 20:11:11\u0026#34;)).getTime(); var curTime = new Date(oldTime).format(\u0026#34;yyyy-MM-dd\u0026#34;); console.log(curTime);   运行如下：\n3. 将 \u0026ldquo;时间戳\u0026rdquo; 转换为 \u0026ldquo;年月日\u0026rdquo; 的格式.\n比如如下代码：\n1 2 3 4 5 6  var da = 1402233166999; da = new Date(da); var year = da.getFullYear()+\u0026#39;年\u0026#39;; var month = da.getMonth()+1+\u0026#39;月\u0026#39;; var date = da.getDate()+\u0026#39;日\u0026#39;; console.log([year,month,date].join(\u0026#39;-\u0026#39;));   运行如下：\n","description":"","id":33,"section":"posts","tags":null,"title":"","uri":"https://ymmeng.github.io/zh/posts/%E5%89%8D%E7%AB%AF/js%E6%97%A5%E6%9C%9F%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/"},{"content":"1 2 3 4  php artisan make:controller TaskController #创建控制器 php artisan make:controller BlogController --resource # php artisan make:controller BlogController --api # php artisan route:list #查看项目注册的路由列表   ","description":"","id":34,"section":"posts","tags":null,"title":"","uri":"https://ymmeng.github.io/zh/posts/%E5%89%8D%E7%AB%AF/laravel/"},{"content":"VUE常用标签 1 2 3 4 5 6 7 8 9 10 11 12 13  v-text\t#显示文本 v-html\t#渲染html v-on\t点击事件\t常用: @click @keyup.enter v-show\t#根据表达式的真假切换元素的显示，display v-if\t#根据表达式的真假切换元素的显示，dom元素 v-bind\t#设置元素的属性 写法：`:属性名` v-for\t#根据数据生成列表结构 语法：`(item,index) in data` v-model\t#获取和设置表单元素的值（双向数据绑定）   ","description":"","id":35,"section":"posts","tags":null,"title":"","uri":"https://ymmeng.github.io/zh/posts/%E5%89%8D%E7%AB%AF/vue%E6%A0%87%E7%AD%BE/"},{"content":"移动端基本概念 css像素\n物理像素\n本位像素\npc端窗口\n移动端窗口\n1 2 3  var layout = document.documentElement.clientWidth;//layout的宽度，没有兼容性问题\rvar visual = window.innerWidth;//Visual的宽度，接近全部支持\rvar dream = screen.width;//一半代表理想视口的宽度，一般代表设备的分辨率！有很大的兼容性问题\r  developer.mozilla.org\n","description":"","id":36,"section":"posts","tags":null,"title":"","uri":"https://ymmeng.github.io/zh/posts/%E5%89%8D%E7%AB%AF/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"content":"1 2 3  DocumentRoot \u0026#34;/var/www/html\u0026#34;\t#指定虚拟目录 ServerName www.baidu.com\t#虚拟目录绑定的域名 DirectoryIndex aa.php\t#默认首页文件   ","description":"","id":37,"section":"posts","tags":null,"title":"","uri":"https://ymmeng.github.io/zh/posts/%E8%BF%90%E7%BB%B4/apache/"},{"content":"Docker Compose基础指令 快速入门 准备工作 1 2  yum install python-pip yum -y install epel-release   来个练习吧 1.1为项目创建目录 1 2  mkdir composetest cd composetest   1.2在项目目录中创建一个app.py的文件： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  import time import redis from flask import Flask app = Flask(__name__) cache = redis.Redis(host=\u0026#39;redis\u0026#39;, port=6379) def get_hit_count(): retries = 5 while True: try: return cache.incr(\u0026#39;hits\u0026#39;) except redis.exceptions.ConnectionError as exc: if retries == 0: raise exc retries -= 1 time.sleep(0.5) @app.route(\u0026#39;/\u0026#39;) def hello(): count = get_hit_count() return \u0026#39;Hello World! I have been seen {} times.\\n\u0026#39;.format(count)   1.3在项目的目录中创建一个requirements.txt文件： 1 2  flask redis   1.4在项目目录中创建一个Dockerfile文件： 1 2 3 4 5 6 7 8 9 10  FROM python:3.7-alpine WORKDIR /code ENV FLASK_APP=app.py ENV FLASK_RUN_HOST=0.0.0.0 RUN apk add --no-cache gcc musl-dev linux-headers COPY requirements.txt requirements.txt RUN pip install -r requirements.txt EXPOSE 5000 COPY . . CMD [\u0026#34;flask\u0026#34;, \u0026#34;run\u0026#34;]   1.5在项目目录中创建一个名为docker-compose.yml文件： 1 2 3 4 5 6 7 8  version: \u0026#34;3.8\u0026#34; services: web: build: . ports: - \u0026#34;5000:5000\u0026#34; redis: image: \u0026#34;redis:alpine\u0026#34;   1.6启动 1 2 3 4  docker-compose build docker-compose up -d 后台启动 docker-compose up --build #重新构建   1.7查看网络配置 1  docker network inspect composetest_default   yaml规则 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #3层 version: \u0026#39;3.8\u0026#39; services: 服务1：web #服务配置 images build network ... 服务2：redis ... 服务3：redis ... #其他配置 网络/卷、全局规则 volumes: networks: configs:   Docker-Compose常用命令详解 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  docker-compose --help Usage: docker-compose [-f \u0026lt;arg\u0026gt;...] [options] [COMMAND] [ARGS...] docker-compose -h|--help Options: -f, --file FILE 文件件文件指定另一个合成文件(default: docker-compose.yml) -p, --project-name NAME 项目名称指定备用项目名称(default: directory name) --verbose Show more output --log-level LEVEL Set log level (DEBUG, INFO, WARNING, ERROR, CRITICAL) --no-ansi Do not print ANSI control characters -v, --version Print version and exit -H, --host HOST Daemon socket to connect to --tls Use TLS; implied by --tlsverify --tlscacert CA_PATH Trust certs signed only by this CA --tlscert CLIENT_CERT_PATH Path to TLS certificate file --tlskey TLS_KEY_PATH Path to TLS key file --tlsverify Use TLS and verify the remote --skip-hostname-check Don\u0026#39;t check the daemon\u0026#39;s hostname against the name specified in the client certificate --project-directory PATH Specify an alternate working directory (default: the path of the Compose file) --compatibility If set, Compose will attempt to convert keys in v3 files to their non-Swarm equivalent --env-file PATH Specify an alternate environment file Commands: build #生成或重建服务 bundle #从Compose文件生成Docker bundle config #验证并查看撰写文件 create #创建服务 down #停止并删除容器、网络、映像和卷 events #从容器接收实时事件 exec #在正在运行的容器中执行命令 help #获取命令帮助 images #列出图像 kill #杀死容器 logs #查看容器的输出 pause #暂停服务 port #打印端口绑定的公共端口 ps #列出容器 pull #拉取服务映像 push #推送服务映像 restart #重新启动服务 rm #移除停止的容器 run #运行一次性命令 scale #服务集装箱数量 start #启动服务 stop #停止服务 top #显示正在运行的进程 unpause #取消暂停服务 up #创建并启动容器 version #显示Docker Compose版本信息   Docker swarm 3.1初始化 1  docker swarm init --advertise-addr 192.168.58.104   3.2获取令牌 1 2 3 4  docker swarm join-token manager #生成管理令牌 docker swarm join-token worker #生成一个命令，然后给其他的机器使用。 docker node ls\t#查看这个集群下面的节点 docker swarm   Docker Start Docker Secret Docker Config ","description":"","id":38,"section":"posts","tags":null,"title":"","uri":"https://ymmeng.github.io/zh/posts/%E8%BF%90%E7%BB%B4/docker-compose%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/"},{"content":"Docker安装以及常用操作 1、安装Docker 1.1安装gcc和gcc-c++ 1  yum -y install gcc \u0026amp;\u0026amp;yum -y install gcc-c++\r  1.2安装 utils 1  yum install -y yum-utils\r  1.3安装Docker 1 2 3  yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\ryum makecache fast\ryum install docker-ce docker-ce-cli containerd.io\r  1.4启动Docker 1 2  service docker start\rsystemctl enable docker\r  1.5配置加速器 1 2 3 4 5 6 7  tee /etc/docker/daemon.json \u0026lt;\u0026lt;- \u0026#39;EOF\u0026#39;\r{\r\u0026#34;registry-mirrors\u0026#34;:[\u0026#34;https://qiyb9988.mirror.aliyuncs.com\u0026#34;]\r}\rsystemctl daemon-reload\rsystemctl restart docker\rsystemctl reset-failed docker.service\r  1.6卸载Docker 1 2 3 4 5 6 7 8  sudo yum remove docker \\\r docker-client \\\r docker-client-latest \\\r docker-common \\\r docker-latest \\\r docker-latest-logrotate \\\r docker-logrotate \\\r docker-engine\r  2、Docker基本操作 2.1安装Nginx 1 2 3 4 5 6 7 8  docker search nginx\t#搜索镜像\rdockerpull nginx\t#下载\tdocker run -d --name nginx01 -p 3344:80 nginx\t#后台启动\rdocker ps\t#查看进程\rcurl localhost:3344\t#查看访问源代码\rdocker exec -it nginx01 /bin/bash\t#进入容器\rexit\t#退出容器\rdocker stop id\t#停止nginx\r  2.2安装Mysql  #3306端口\troot密码123456\n 1  docker run -d -p 3306:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql\r  3、Docker常用命令： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42  docker pull ${CONTAINERNAME} #拉取镜像\rdocker images #查看本地所有镜像\rdocker ps #查看所有正在运行的容器，加-q返回id\rdocker ps -a #查看所有容器，加-q返回id\rdocker rmi ${IMAGENAME/ID} #删除镜像\rdocker rm ${CONTAINERNAME/ID} #删除容器\rdocker save ${IMAGENAME} \u0026gt; ${FILENAME}.tar #将镜像保存成文件\rdocker load \u0026lt; ${FILENAME}.tar #从文件加载镜像\rdocker start ${CONTAINERNAME/ID} #运行一个以前运行过的容器\rdocker stop ${CONTAINERNAME/ID} #停止一个正在运行的容器\rdocker logs ${CONTAINERNAME/ID} #显示运行容器的日志\rdocker run... #运行一个容器\r--name ${containername} #设置容器名称\r-p ${hostport}:${containerport} #映射主机和容器内的端口\r-e ${envname}=${envvalue} #添加环境变量\r-d #后台运行\r-v ${hostfolder path}:${containerfolder path} #将主机目录挂在到容器内\r# Advance use docker ps -f \u0026#34;status=exited\u0026#34; #显示所有退出的容器\rdocker ps -a -q #显示所有容器id\rdocker ps -f \u0026#34;status=exited\u0026#34; -q #显示所有退出容器的id\rdocker restart $(docker ps -q) #重启所有正在运行的容器\rdocker stop $(docker ps -a -q) #停止所有容器\rdocker rm $(docker ps -a -q) #删除所有容器\rdocker rm $(docker ps -f \u0026#34;status=exited\u0026#34; -q) #删除所有退出的容器\rdocker rm $(docker stop $(docker ps -a -q)) #停止并删除所有容器\rdocker start $(docker ps -a -q) #启动所有容器\rdocker rmi $(docker images -a -q) #删除所有镜像\rdocker exec -it ${CONTAINERNAME/ID} /bin/bash #进入容器内\rdocker exec -it ${CONTAINERNAME/ID} ping ${CONTAINERNAME/ID} #一个容器ping另外一个容器\rdocker top ${CONTAINERNAME/ID} #显示一个容器的top信息\rdocker stats #显示容器统计信息(正在运行)\rdocker stats -a #显示所有容器的统计信息(包括没有运行的)\rdocker stats -a --no-stream #显示所有容器的统计信息(包括没有运行的) ，只显示一次\rdocker stats --no-stream | sort -k8 -h #统计容器信息并以使用流量作为倒序\rdocker system docker system df #显示硬盘占用\rdocker system events #显示容器的实时事件\rdocker system info #显示系统信息\rdocker system prune #清理文件\r  ","description":"","id":39,"section":"posts","tags":null,"title":"","uri":"https://ymmeng.github.io/zh/posts/%E8%BF%90%E7%BB%B4/docker%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"},{"content":"MongoDB基础操作 查看数据库 语法\n show databases\n 效果\n1 2 3 4 5 6  \u0026gt; show databases admin 0.000GB canaan 0.000GB canaan_test 0.002GB config 0.000GB local 0.000GB   选择/创建数据库 语法\n use  #有数据则选择，没有则创建\n 删除数据库 语法\n db.dropDatabase()\n 查看集合 语法\n show clooections\n 效果\n1 2 3  \u0026gt; show collections associated_records records   创建集合 语法\n db.createCollection(\u0026lsquo;集合名\u0026rsquo;) #插入数据时自动创建集合\n 删除集合 语法\n db.集合名.drop()\n ","description":"","id":40,"section":"posts","tags":null,"title":"","uri":"https://ymmeng.github.io/zh/posts/%E8%BF%90%E7%BB%B4/mongodb%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/"},{"content":"Mysql8.0笔记 零、用户管理： 1 2 3 4 5 6  1、新建用户：CREATE USER name IDENTIFIED BY \u0026#39;ssapdrow\u0026#39;; 2、更改密码：SET PASSWORD FOR name=PASSWORD(\u0026#39;fdddfd\u0026#39;); 3、权限管理: SHOW GRANTS FOR name; //查看name用户权限 GRANT SELECT ON db_name.* TO name;　//给name用户db_name数据库的所有权限 REVOKE SELECT ON db_name.* TO name;　//GRANT的反操作，去除权限；   一、数据库操作：　 1 2 3 4 5 6 7 8 9 10  1、查看数据库： \u0026gt;SHOW DATABASES; 2、创建数据库： \u0026gt;CREATE DATABASE db_name;　//db_name为数据库名 3、使用数据库： \u0026gt;USE db_name; 4、删除数据库： \u0026gt;DROP DATABASE db_name; 5、查看端口： \u0026gt;show global variables like \u0026#39;port\u0026#39;;   二、创建表： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  1、创建表： \u0026gt;CREATE TABLE table_name( \u0026gt;id TINYINT UNSIGNED NOT NULL AUTO_INCREMENT,　//id值，无符号、非空、递增——唯一性，可做主键。 \u0026gt;name VARCHAR(60) NOT NULL \u0026gt;score TINYINT UNSIGNED NOT NULL DEFAULT 0,　//设置默认列值 \u0026gt;PRIMARY KEY(id) \u0026gt;)ENGINE=InnoDB　//设置表的存储引擎，一般常用InnoDB和MyISAM；InnoDB可靠，支持事务；MyISAM高效不支持全文检索 \u0026gt;DEFAULT charset=utf8;　//设置默认的编码，防止数据库中文乱码 如果有条件的创建数据表还可以使用 \u0026gt;CREATE TABLE IF NOT EXISTS tb_name(........ 2、复制表： \u0026gt;CREATE TABLE tb_name2 SELECT * FROM tb_name; 或者部分复制： \u0026gt;CREATE TABLE tb_name2 SELECT id,name FROM tb_name; 3、创建临时表： \u0026gt;CREATE TEMPORARY TABLE tb_name(这里和创建普通表一样); 4、查看数据库中可用的表： \u0026gt;SHOW TABLES; 5、查看表的结构： \u0026gt;DESCRIBE tb_name; 也可以使用： \u0026gt;SHOW COLUMNS in tb_name; //from也可以 6、删除表： \u0026gt;DROP [ TEMPORARY ] TABLE [ IF EXISTS ] tb_name[ ,tb_name2.......]; 实例： \u0026gt;DROP TABLE IF EXISTS tb_name; 7、表重命名： \u0026gt;RENAME TABLE name_old TO name_new; 还可以使用： \u0026gt;ALTER TABLE name_old RENAME name_new;   三、修改表： 1 2 3 4 5 6  1、更改表结构： \u0026gt;ALTER TABLE tb_name ADD[CHANGE,RENAME,DROP] ...要更改的内容... 实例： \u0026gt;ALTER TABLE tb_name ADD COLUMN address varchar(80) NOT NULL; \u0026gt;ALTER TABLE tb_name DROP address; \u0026gt;ALTER TABLE tb_name CHANGE score score SMALLINT(4) NOT NULL;   四、插入数据： 1 2 3 4 5  1、插入数据： \u0026gt;INSERT INTO tb_name(id,name,score)VALUES(NULL,\u0026#39;张三\u0026#39;,140),(NULL,\u0026#39;张四\u0026#39;,178),(NULL,\u0026#39;张五\u0026#39;,134); 这里的插入多条数据直接在后边加上逗号，直接写入插入的数据即可；主键id是自增的列，可以不用写。 2、插入检索出来的数据： \u0026gt;INSERT INTO tb_name(name,score) SELECT name,score FROM tb_name2;   五、更新数据： 　1、指定更新数据：\n 　\u0026gt;UPDATE tb_name SET score=189 WHERE id=2;\n　\u0026gt;UPDATE tablename SET columnName=NewValue [ WHERE condition ]\n 六、删除数据： 　1、删除数据：\n　\u0026gt;DELETE FROM tb_name WHERE id=3;\n七、条件控制： 　1、WHERE 语句：\n　\u0026gt;SELECT * FROM tb_name WHERE id=3;\n　2、HAVING 语句：\n　\u0026gt;SELECT * FROM tb_name GROUP BY score HAVING count(*)\u0026gt;2\n　3、相关条件控制符：\n　=、\u0026gt;、\u0026lt;、\u0026lt;\u0026gt;、IN(1,2,3\u0026hellip;\u0026hellip;)、BETWEEN a AND b、NOT\n　AND 、OR\n　Linke()用法中 % 为匹配任意、 _ 匹配一个字符（可以是汉字）\n　IS NULL 空值检测\n八、MySQL的正则表达式： 　1、Mysql支持REGEXP的正则表达式：\n　\u0026gt;SELECT * FROM tb_name WHERE name REGEXP \u0026lsquo;^[A-D]\u0026rsquo; //找出以A-D 为开头的name\n　2、特殊字符需要转义。\n九、MySQL的一些函数： 　1、字符串链接——CONCAT()\n　\u0026gt;SELECT CONCAT(name,\u0026lsquo;=\u0026gt;\u0026rsquo;,score) FROM tb_name\n　2、数学函数：\n　AVG、SUM、MAX、MIN、COUNT；\n　3、文本处理函数：\n　TRIM、LOCATE、UPPER、LOWER、SUBSTRING\n　4、运算符：\n　+、-、*、\\\n　5、时间函数：\n　DATE()、CURTIME()、DAY()、YEAR()、NOW()\u0026hellip;..\n十、分组查询： 　1、分组查询可以按照指定的列进行分组：\n　\u0026gt;SELECT COUNT() FROM tb_name GROUP BY score HAVING COUNT()\u0026gt;1;\n　2、条件使用Having；\n　3、ORDER BY 排序：\n　ORDER BY DESC|ASC　=\u0026gt;按数据的降序和升序排列\n十一、UNION规则——可以执行两个语句（可以去除重复行） 十二、全文检索——MATCH和AGAINST 　1、SELECT MATCH(note_text)AGAINST(\u0026lsquo;PICASO\u0026rsquo;) FROM tb_name;\n　2、InnoDB引擎不支持全文检索，MyISAM可以；\n十三、视图 　1、创建视图\n　\u0026gt;CREATE VIEW name AS SELECT * FROM tb_name WHERE ~~ ORDER BY ~~;\n　2、视图的特殊作用：\n　a、简化表之间的联结（把联结写在select中）；\n　b、重新格式化输出检索的数据（TRIM，CONCAT等函数）；\n　c、过滤不想要的数据（select部分）\n　d、使用视图计算字段值，如汇总这样的值。\n十四、使用存储过程： 　个人理解，存储过程就是一个自定义函数，有局部变量参数，可传入参数，可以返回值，不过这语法够呆滞的~~~\n　1、创建存储过程：\n　\u0026gt;CREATE PROCEDURE pro(\n　\u0026gt;IN num INT,OUT total INT)\n　\u0026gt;BEGIN\n　\u0026gt;SELECT SUM(score) INTO total FROM tb_name WHERE id=num;\n　\u0026gt;END;\n　***这里的 IN (传递一个值给存储过程)，OUT（从存储过程传出一个值），INOUT（对存储过程传入、传出），INTO（保存变量）\n　2、调用存储过程：\n　\u0026gt;CALL pro(13,@total)　//这里的存储过程两个变量，一个是IN一个是OUT，这里的OUT也是需要写上的，不写会出错\n　\u0026gt;SELECT @total　//这里就可以看到结果了；\n　3、存储过程的其他操作：\n　\u0026gt;SHOW PROCEDURE STATUS;　//显示当期的存储过程\n　\u0026gt;DROP PROCEDURE pro;　//删除指定存储过程\n十五、使用游标： 　对这个理解不是很懂，朋友多多指点哦~~~\n　1、游标的操作\n　\u0026gt;CREATE PROCEDURE pro()\n　\u0026gt;BEGIN\n　\u0026gt;DECLARE ordername CURSOR FOR\n　\u0026gt;SELECT order_num FROM orders;\n　\u0026gt;END;\n　\u0026gt;OPEN ordername;　//打开游标\n　\u0026gt;CLOSE ordername;　//关闭游标\n十六、触发器： 　触发器是指在进行某项指定操作时，触发触发器内指定的操作；\n　1、支持触发器的语句有DELETE、INSERT、UPDATE,其他均不支持\n　2、创建触发器：\n　\u0026gt;CREATE TRIGGER trig AFTER INSERT ON ORDERS FOR EACH ROW SELECT NEW.orser_name;\n　\u0026gt;INSERT语句，触发语句，返回一个值\n　3、删除触发器\n　\u0026gt;DROP TRIGGER trig;\n十七、语法整理： 　1、ALTER TABLE（修改表）\n　ALTER TABLE table_name\n　(　ADD　column　datatype [ NULL | NOT NULL ]　[ CONSTRAINTS ]\n　CHANGE　column datatype COLUMNS　[ NULL | NOT NULL ]　[ CONSTRAINTS ]\n　DROP　column，\n　。。。。\n　)\n　2、COMMIT(处理事务)\n　\u0026gt;COMMIT;\n　3、CREATE INDEX(在一个或多个列上创建索引)\n　CREATE INDEX index_name ON tb_name (column [ ASC | DESC ] , \u0026hellip;\u0026hellip;.);\n　4、CREATE PROCEDURE (创建存储过程)\n　CREATE PROCEDURE pro([ parameters ])\n　BEGIN\n　\u0026hellip;\u0026hellip;..\n　END\n　5、CREATE TABLE(创建表)\n　CREATE TABLE tb_name(\n　column_name　datetype　[ NULL | NOT NULL ] [ condtraints] ,\n　column_name　datetype　[ NULL | NOT NULL ] [ condtraints] ,\n　\u0026hellip;\u0026hellip;.\n　PRIMARY KEY( column_name )\n　)ENGINE=[ InnoDB | MyiSAM ]DEFAULT CHARSET=utf8 AUTO_INCREMENT=1 ;\n　6、CREATE USER(创建用户)\n　CREATE USER user_name [ @hostname ] [ IDENTIFIED BY [ PASSWORD ] \u0026lsquo;pass_word\u0026rsquo; ];\n　7、CREATE VIEW （在一个或多个表上创建视图）\n　CREATE [ OR REPLACE ] VIEW view_name AS SELECT。。。。。。\n　8、DELETE (从表中删除一行或多行)\n　DELETE FROM table_name [WHERE \u0026hellip;\u0026hellip;]\n　9、DROP(永久删除数据库及对象，如视图、索引等)\n　DROP DATEBASE | INDEX | PROCEDURE | TABLE | TRIGGER | USER | VIEW name\n　10、INSERT （给表添加行）\n　INSERT INTO tb_name [ ( columns,\u0026hellip;\u0026hellip; ) ] VALUES(value1,\u0026hellip;\u0026hellip;\u0026hellip;\u0026hellip;);\n　使用SELECT值插入：\n　INSERT INTO tb_name [ ( columns,\u0026hellip;\u0026hellip; ) ]\n　SELECT columns , \u0026hellip;\u0026hellip;. FROM tb_name [ WHERE \u0026hellip;\u0026hellip; ] ;\n　11、ROLLBACK（撤销一个事务处理块）\n　ROLLBACK [ TO savapointname ];\n　12、SAVEPOINT(为ROLLBACK设置保留点)\n　SAVEPOINT sp1;\n　13、SELECT (检索数据，显示信息)\n　SELECT column_name,\u0026hellip;..FROM tb_name [ WHERE ] [ UNION ] [ RROUP BY ] [ HAVING ] [ ORDER BY ]\n　14、START TRANSACTION (一个新的事务处理块的开始)\n　START TRANSACTION\n　15、UPDATE(更新一个表中的一行或多行)\n　UPDATE tb_name SET column=value,\u0026hellip;\u0026hellip;[ where ]\n","description":"","id":41,"section":"posts","tags":null,"title":"","uri":"https://ymmeng.github.io/zh/posts/%E8%BF%90%E7%BB%B4/mysql8.0%E7%AC%94%E8%AE%B0/"},{"content":"Redis学习笔记 安装 在线安装 直接输入命令\n1  sudo apt-get install redis-server   安装完成后，Redis服务器会自动启动。使用以下命令可以看到服务器系统进程默认端口6379\n1  ps -aux|grep redis   下载安装包：   下载：打开redis官方网站，推荐下载稳定版本(stable)\n1  wget http://download.redis.io/releases/redis-5.0.5.tar.gz     解压\n1  tar xzf redis-5.0.5.tar.gz     复制：推荐放到usr/local目录下\n1  sudo mv redis-5.0.5 /usr/local/redis     进入redis目录 cd /usr/local/redis/\n  生成:sudo make失败则 使用 sudo make MALLOC=libc后再sudo make\n  测试 sudo make test 这段运行时间会较长\n  安装：将redis的命令安装到/usr/bin/目录sudo make install\n  运行 redis-server 按ctrl+c停止\n  常用操作 启动\n1  redis-server /配置文件路径   连接redis\n1 2  redis-cli redis-cli --raw\t#显示中文   测试联通性\n1 2  \u0026gt;127.0.0.1:6379\u0026gt; ping \u0026gt;PONG   切换数据库（最多到15，共有16个数据库）\n1 2  \u0026gt; 127.0.0.1:6379[4]\u0026gt; select 15 \u0026gt; OK   清空数据库\n1 2  flushdb\t#清空当前数据库 flushall\t#清空所有数据库   压力测试： 1 2 3 4 5  redis-benchmark -h localhost -p 6379 -c 100 -n 1000000 -h\t连接的主机 -p 连接端口 -c 并发数 -n 每个并发的数据量   常用命令 String 1 2 3 4 5 6 7  set key value\t-设置值 get key\t-获取值 mset k1 v1 k2 v2\t-同时设置多个值 mget k1 k2\t-同时获取多个值 append key value\t-向key中添加内容 setex msetnx\t-原子性操作，要么都成功，要么都失败   Hash 1 2 3 4 5  hset hmset hget hmget hdel   List 1 2 3 4 5 6 7  lpush list value\t-将一个值或者多个值，插入到列表头部 rpush list value\t-将一个值或者多个值，插入到列表尾部 lrange list index\t-取值，从尾取 rrange list index\t-取值，从头取 lpop list\t-移除list尾部元素 rpop list\t-移除list头部元素 lrem list 1 value\t-移除指定数量的值   Set 1 2 3  sadd key v1 v2 v3\t-向集合中添加数据 smembers key\t-取集合中值 srem   Zset 1 2 3 4 5 6  zadd key 1 v1 2 v2\t-设置权重 zrange key start end zrangebyscore key min max zscore 查询权重 zrem key value zremrangebyscore k1 10 20\t-删除10~30权重之间的值   键 1 2 3 4 5 6 7 8 9  keys *\t-获取所有key EXPIRE key 10 -设置key的过期时间，单位秒 EXISTS key\t-查看key是否存在 ttl key -查看可以的剩余时间 type key -c查看key的类型 incr key\t-自增1 decr key\t-自减1 incrby key 10 decrby key 5   ","description":"","id":42,"section":"posts","tags":null,"title":"","uri":"https://ymmeng.github.io/zh/posts/%E8%BF%90%E7%BB%B4/redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"content":"Ubuntu20.04防火墙 1.安装 Ubuntu20.04一般都默认安装了UFW（Uncomplicated Firewall），它是一款轻量化的工具，主要用于对输入输出的流量进行监控。如果没有安装，请用下面的命令安装：\n1  sudo apt install ufw   正常情况安装以后应该是默认禁止状态的，输入sudo ufw status verbose命令可以看到如下界面：\n这表示防火墙没有开启，下面启用防火墙。\n2.启用 终端中输入如下命令：\n1 2  sudo ufw enable sudo ufw default deny   运行以上两条命令后，开启了防火墙，并在系统启动时自动开启。再次输入sudo ufw status verbose，可以看到如下界面：\n上面的默认配置表示关闭所有外部对本机的访问，但本机访问外部正常，同时我又开启了3690端口，允许外部通过3690端口访问本机，这里说下，SVN默认使用的就是3690端口，这样我就可以从外部通过SVN提交代码到本机了。\n3.开启/禁用 一般的用户，只需设置如下三条命令：\n1 2 3  sudo apt install ufw sudo ufw enable sudo ufw default deny   就已经足够安全了，如果你需要开放某些服务，再使用sudo ufw allow命令开启，举例如下：\n1  sudo ufw allow | deny [service]   打开或关闭某个端口，例如：\n1 2 3 4 5 6 7 8 9  sudo ufw allow 53 允许外部访问53端口(tcp/udp) sudo ufw allow 3690 允许外部访问3690端口(svn) sudo ufw allow from 192.168.1.111 允许此IP访问所有的本机端口 sudo ufw allow proto tcp from 192.168.0.0/24 to any port 22 允许指定的IP段访问特定端口 sudo ufw delete allow smtp 删除上面建立的某条规则，比如删除svn端口就是 sudo ufw delete allow 3690   4.开启/关闭防火墙 1  sudo ufw enable | disable   5.示例 1 2 3 4 5 6 7 8 9 10 11 12 13  下面是ufw命令行的一些示例： ufw enable/disable：打开/关闭ufw ufw status：查看已经定义的ufw规则 ufw default allow/deny：外来访问默认允许/拒绝 ufw allow/deny 20：允许/拒绝访问20端口，20后可跟/tcp或/udp，表示tcp或udp封包。 sudo ufw allow proto tcp from 192.168.0.0/24 to any port 22：允许自192.168.0.0/24的tcp封包访问本机的22端口。 ufw delete allow/deny 20：删除以前定义的\u0026#34;允许/拒绝访问20端口\u0026#34;的规则   tps：新手或者嫌弃命令行麻烦的可以使用gufw 1  sudo apt install gufw   ","description":"","id":43,"section":"posts","tags":null,"title":"","uri":"https://ymmeng.github.io/zh/posts/%E8%BF%90%E7%BB%B4/ubuntu20.04%E9%98%B2%E7%81%AB%E5%A2%99/"},{"content":"Ubuntu安装Nginx和正确卸载Nginx Nginx相关 1.Ubuntu下安装Nginx比较简单 敲入下列命令即可：\n1 2  sudo apt-get update sudo apt-get install nginx   2.Ubuntu下卸载，稍不注意就会入坑 1 2 3 4  sudo apt-get remove nginx nginx-common # 卸载删除除了配置文件以外的所有文件。 sudo apt-get purge nginx nginx-common # 卸载所有东东，包括删除配置文件。 sudo apt-get autoremove # 在上面命令结束后执行，主要是卸载删除Nginx的不再被使用的依赖包。 sudo apt-get remove nginx-full nginx-common #卸载删除两个主要的包。　sudo service nginx restart #重启nginx   上面的命令基本上都能解决你在Ubuntu下安装卸载Nginx的问题。\n3.查看nginx进程 1 2 3 4 5 6 7 8 9 10 11 12 13 14  ps aux|grep nginx 在虚拟环境下安装uwsgi pip install uwsgi ######启动Nginx服务 [root@typecodes ~]# service nginx start ######停止Nginx服务 [root@typecodes ~]# service nginx stop ######重启Nginx服务 [root@typecodes ~]# service nginx restart ######Nginx服务的状态 [root@typecodes ~]# service nginx status ######在Nginx服务启动的状态下，重新加载nginx.conf这个配置文件 [root@typecodes ~]# service nginx reload   一、安装Nginx 　Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好。\nNginx同样为当前非常流行的web服务器。利用其部署Django，我们在此也做简单的介绍。\nNginx官网：http://nginx.org/\n打开ubuntu控制台（ctrl+alt+t）利用Ubuntu的仓库安装。\n1  fnngj@ubuntu:~$ sudo apt-get install nginx #安装   启动Nginx：\n1 2 3  fnngj@ubuntu:~$ /etc/init.d/nginx start #启动 fnngj@ubuntu:~$ /etc/init.d/nginx stop #关闭 fnngj@ubuntu:~$ /etc/init.d/nginx restart #重启   修改Nginx默认端口号，打开/etc/nginx/nginx.conf 文件，修改端口号。\n1 2 3 4 5 6 7 8 9  server { listen 8088; # 修改端口号 server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { root html; index index.html index.htm; }   　大概在文件36行的位置，将默认的80端口号改成其它端口号，如 8088。因为默认的80端口号很容易被其它应用程序占用。\n　然后，通过上面命令重启nginx。访问：http://127.0.0.1:8088/\n　　如果出现如上图，说明Nginx启动成功。\n二、安装uwsgi 通过pip安装uwsgi。\n1  root@ubuntu:/etc# python3 -m pip install uwsgi   测试uwsgi，创建test.py文件：\n1 2 3  def application(env, start_response): start_response(\u0026#39;200 OK\u0026#39;, [(\u0026#39;Content-Type\u0026#39;,\u0026#39;text/html\u0026#39;)]) return [b\u0026#34;Hello World\u0026#34;]   通过uwsgi运行该文件。\n1  fnngj@ubuntu:~/pydj$ uwsgi --http :8001 --wsgi-file test.py   接下来配置Django与uwsgi连接。此处，假定的我的django项目位置为：/home/fnngj/pydj/myweb\n1  fnngj@ubuntu:~/pydj$ uwsgi --http :8001 --chdir /home/fnngj/pydj/myweb/ --wsgi-file myweb/wsgi.py --master --processes 4 --threads 2 --stats 127.0.0.1:9191   常用选项：\nhttp ： 协议类型和端口号\nprocesses ： 开启的进程数量\nworkers ： 开启的进程数量，等同于processes（官网的说法是spawn the specified number ofworkers / processes）\nchdir ： 指定运行目录（chdir to specified directory before apps loading）\nwsgi-file ： 载入wsgi-file（load .wsgi file）\nstats ： 在指定的地址上，开启状态服务（enable the stats server on the specified address）\nthreads ： 运行线程。由于GIL的存在，我觉得这个真心没啥用。（run each worker in prethreaded mode with the specified number of threads）\nmaster ： 允许主进程存在（enable master process）\ndaemonize ： 使进程在后台运行，并将日志打到指定的日志文件或者udp服务器（daemonize uWSGI）。实际上最常用的，还是把运行记录输出到一个本地文件上。\npidfile ： 指定pid文件的位置，记录主进程的pid号。\nvacuum ： 当服务器退出的时候自动清理环境，删除unix socket文件和pid文件（try to remove all of the generated file/sockets）\n三、Nginx+uwsgi+Django 　接下来，我们要将三者结合起来。首先罗列一下项目的所需要的文件：\nmyweb/\n├── manage.py\n├── myweb/\n│ ├── init.py\n│ ├── settings.py\n│ ├── urls.py\n│ └── wsgi.py\n└── myweb_uwsgi.ini\n　在我们通过Django创建myweb项目时，在子目录myweb下已经帮我们生成的 wsgi.py文件。所以，我们只需要再创建myweb_uwsgi.ini配置文件即可，当然，uwsgi支持多种类型的配置文件，如xml，ini等。此处，使用ini类型的配置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  # myweb_uwsgi.ini file [uwsgi] # Django-related settings socket = :8000 # the base directory (full path) chdir = /home/fnngj/pydj/myweb # Django s wsgi file module = myweb.wsgi # process-related settings # master master = true # maximum number of worker processes processes = 4 # ... with appropriate permissions - may be needed # chmod-socket = 664 # clear environment on exit vacuum = true   　这个配置，其实就相当于在上一小节中通过wsgi命令，后面跟一堆参数的方式，给文件化了。\n　socket 指定项目执行的端口号。\n　chdir 指定项目的目录。\n　module myweb.wsgi ，可以这么来理解，对于myweb_uwsgi.ini文件来说，与它的平级的有一个myweb目录，这个目录下有一个wsgi.py文件。\n　其它几个参数，可以参考上一小节中参数的介绍。\n　接下来，切换到myweb项目目录下，通过uwsgi命令读取myweb_uwsgi.ini文件启动项目。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  fnngj@ubuntu:~$ cd /home/fnngj/pydj/myweb/ fnngj@ubuntu:~/pydj/myweb$ uwsgi --ini myweb_uwsgi.ini [uWSGI] getting INI configuration from myweb_uwsgi.ini *** Starting uWSGI 2.0.12 (32bit) on [Sat Mar 12 13:05:06 2016] *** compiled with version: 4.8.4 on 26 January 2016 06:14:41 os: Linux-3.19.0-25-generic #26~14.04.1-Ubuntu SMP Fri Jul 24 21:18:00 UTC 2015 nodename: ubuntu machine: i686 clock source: unix detected number of CPU cores: 2 current working directory: /home/fnngj/pydj/myweb detected binary path: /usr/local/bin/uwsgi !!! no internal routing support, rebuild with pcre support !!! chdir() to /home/fnngj/pydj/myweb your processes number limit is 15962 your memory page size is 4096 bytes detected max file descriptor number: 1024 lock engine: pthread robust mutexes thunder lock: disabled (you can enable it with --thunder-lock) uwsgi socket 0 bound to TCP address :8000 fd 3 Python version: 3.4.3 (default, Oct 14 2015, 20:37:06) [GCC 4.8.4] *** Python threads support is disabled. You can enable it with --enable-threads *** Python main interpreter initialized at 0x8b52dc0 your server socket listen backlog is limited to 100 connections your mercy for graceful operations on workers is 60 seconds mapped 319920 bytes (312 KB) for 4 cores *** Operational MODE: preforking *** WSGI app 0 (mountpoint=\u0026#39;\u0026#39;) ready in 1 seconds on interpreter 0x8b52dc0 pid: 7158 (default app) *** uWSGI is running in multiple interpreter mode *** spawned uWSGI master process (pid: 7158) spawned uWSGI worker 1 (pid: 7160, cores: 1) spawned uWSGI worker 2 (pid: 7161, cores: 1) spawned uWSGI worker 3 (pid: 7162, cores: 1) spawned uWSGI worker 4 (pid: 7163, cores: 1)   注意查看uwsgi的启动信息，如果有错，就要检查配置文件的参数是否设置有误。\n再接下来要做的就是修改nginx.conf配置文件。打开/etc/nginx/nginx.conf文件，添加如下内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  …… server { listen 8099; server_name 127.0.0.1 charset UTF-8; access_log /var/log/nginx/myweb_access.log; error_log /var/log/nginx/myweb_error.log; client_max_body_size 75M; location / { include uwsgi_params; uwsgi_pass 127.0.0.1:8000; uwsgi_read_timeout 2; } location /static { expires 30d; autoindex on; add_header Cache-Control private; alias /home/fnngj/pydj/myweb/static/; } } ……   listen 指定的是nginx代理uwsgi对外的端口号。\n　server_name 网上大多资料都是设置的一个网址（例，www.example.com），我这里如果设置成网址无法访问，所以，指定的到了本机默认ip。\n　在进行配置的时候，我有个问题一直想不通。nginx到底是如何uwsgi产生关联。现在看来大概最主要的就是这两行配置。\n　include uwsgi_params;\n　uwsgi_pass 127.0.0.1:8000;\n　include 必须指定为uwsgi_params；而uwsgi_pass指的本机IP的端口与myweb_uwsgi.ini配置文件中的必须一直。\n　现在重新启动nginx，翻看上面重启动nginx的命令。然后，访问：http://127.0.0.1:8099/\n　通过这个IP和端口号的指向，请求应该是先到nginx的。如果你在页面上执行一些请求，就会看到，这些请求最终会转到uwsgi来处理。\n　=============\nps： 这个过程本应不算复杂，之前花两天时间没搞定，索性放到了一边，这次又花了两天时间才算搞定。网上搜到的文章比较乱，有些太简单的看不懂，有些又太啰嗦的不知道核心的几步是什么，希望本文能帮到你。\n","description":"","id":44,"section":"posts","tags":null,"title":"","uri":"https://ymmeng.github.io/zh/posts/%E8%BF%90%E7%BB%B4/ubuntu%E5%AE%89%E8%A3%85nginx%E5%92%8C%E6%AD%A3%E7%A1%AE%E5%8D%B8%E8%BD%BDnginx/"},{"content":"虚拟机Centos8,没有网络，ping不通主机，wired图标消失 我为了解决这个问题呕心沥血两天，任务停滞不前进度为0。解决之后，必须记下来！帮助有相同困难的人！百度上太多解决办法，但其实都没有用！强烈谴责！\n我是在配置ssh文件遇到的问题：\n1  ssh -T git@gitee.com   报错：\n原因是：虚拟机没有联网，没有网络。\n为了给虚拟机联网，百度了配置DNS、配置网关、网卡等等，试了都没用。在此过程中发现虚拟机的wired图标不见了（可能是在瞎捣鼓的时候给弄没了）\n解决办法：\n1  mv /var/lib/NetworkManager /var/lib/NetworkManager.bak   重启后就好了\n然后发现，虚拟机虽然显示“有线 已连接”，但其实仍然访问不了外网。我又开始瞎百度，调了很多东西，什么“编辑 /etc/sysconfig/network-scripts/ifcfg-eth0文件”，什么“设置虚拟机的虚拟网络编辑器”等等，通通没用。\n最后，死马当活马医，输入了几句代码，重启后奇迹般可以联网了。\n1 2 3 4  sudo sysctl net.ipv4.conf.default.rp_filter=0 sudo sysctl net.ipv4.conf.all.rp_filter=0 sudo sysctl net.ipv4.ip_forward=1 sudo sysctl net.ipv6.conf.all.forwarding=1   连上网后，ssh -T git@gitee.com 也没问题了。\nover!\n","description":"","id":45,"section":"posts","tags":null,"title":"","uri":"https://ymmeng.github.io/zh/posts/%E8%BF%90%E7%BB%B4/%E8%99%9A%E6%8B%9F%E6%9C%BAcentos8%E6%B2%A1%E6%9C%89%E7%BD%91%E7%BB%9Cping%E4%B8%8D%E9%80%9A%E4%B8%BB%E6%9C%BAwired%E5%9B%BE%E6%A0%87%E6%B6%88%E5%A4%B1/"}]